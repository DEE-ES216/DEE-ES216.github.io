<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected ES216BB Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected ES216BB Page</p>
                        <p>Enter the password given in the venue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b21f013cb099ede8b252e741cfa9ef85915dbfc28345512af17252a12b4a80d2c1a0fd021f765866a26f4f654b607e0f6ce0d16242a520ff4d5d8beee4511e80fd8708263bc7acaeeea94ed8d39af3ab08ec531feed5a5d470992f521cec4d9f77b025f58b4621d37329ff188ed18406d79381f172778e2e931a125c9a6515336253a1d6eaaf82f33565f24c1415e001fbacbaf22a691287f1e2c7e68ea3e1741adda005fdd695cf0313f6e2050561bacd3aba88636e5a575b570f1138a1b9d313b07e89b2762b05806b7ef50c542803b8f4e66a0c567cd6579aa40b9990056c610eef923c52794f9b04eea9cbe559b8b69c0b0d5a0178d6e72890b6911e57bcdff831895aad0895f677c9365c337a5332716d6b4b6dfe9329c1c83c48e1d613fc2894b3063139ef4a152f2f53449279155a80f1f645418eaf3789095d1c17227d6b402f40e0922519c09bba4370321380974a4e53b1b1d767094929fbb0a3abbe9c9756c45873c23221615795ae81fa91cf712846047cb2415126befd62b6b9a7a828752703278ea2ad3e2bda4e9f9e2d4c22217ed5244c0e0d72179df6a294589b770ab25044f627616eaab3f98798f4462106ada2dae66249fbf1d81b0af660767cc9b36664293115f8183416eff09f6f9734afc33f4db9694f2aab90e21262b7d2a5fbf9d8526b4185beda0d71c80c77b8dd81d2b3fcec1829da4d6a612d998018607cd96f367c1ff958c265ee1be5c001b09761d33b86198ce6e6d1a77832096f1fe5e8f8353d4dcad97da3681c0465585ae4c79a34e53c88a0ff3f92fc13a76ef25e9ed34abb77d43266b13711dd132fb426cbf08d0e814550690bef383b604106c245b5299f0fefbfaf7e1017371a003a12b9ebd78d2d116298d25abf27743393c9b4cd2deeadd46ea65018b864bf75c2575de89c5ec4c5908387b827aa681148f5b2eac900426c464304d367f4e6d040157b4431cf7e3b53ff7951fcac0547947b4665f51b45c65569de63c28cbb2c94328b75fb27974e1ecc67f3199b88d0df623f3943243470def2fb8fd54dd77e9c3fb71ce55f019df6c4ba590b9a673bb46591ee54933ae02da883796367689694277bc015bdbb00f8488a1d842003e35f78eb8cbcfaf394914271ba2f6ba1e458ce490aa0be9497db483753f316e506d5f21b3c5730256840b0454d2226af3502b6efdadde5b117bb2bc656d91f20be2029e4e1c12329e81111cd81147968f53cece3416ac5c626f0581edf4a3101d6af7fafc3627d2bffb9c657718cd934f9b6a67fe32d8ee543e9f3d64cda5851c79d06aa003238d33b85397b089573a2c6ad778bf2ad48f19a4fd37a4913ceac5ed56c87895281bccf52afab398776cca3296aa45d54015038ffdf5f9f61880c489c35114c38b8fc2ed69427a4bc5073cf7507f28d108e114ea1db5fba1a388b84f625a3ea7b71d14f5e4ad9d71c62f56fc003eb62d3e807e791d7b4f8074be9bd493d1b70f3a5f4aec0fb1f164ae42fcabecb7c0a55c06f1642a08b6120798a1afa57aadc72a7c8bd509040ceac333be9ece7cde323cd96d165d90bdef730ccdfbb00bd815c2ba8b007b028708e67dcfb7f5d531ef859bd39a2a6c250b9fb72a97b101f8d701bf0d68f914aede394be68da950c9919043ead67fc2c8e8f16cc788bb1e4fc55dffe1dcfe5f4777d8c917993c8d329ee9adbb156b0c9561d78baf038ad5ba9082cfdee80eaef36e4ecd56645812b8f049f658d22e4930fb9b3bff04f3de71d3e2c54761e25e72e2ddb269a7adfaccd619a528c1bbda7b346204d44e4357389ee4d51112c1b0a55db359cdf4dbacd313a0dd8c0090640f2c90ebc7dbb3d25d471d7d28fc1c6c31e84fcba5a3cd6722abe13a79598a4983d066373adfcac8f933d0211b26f744b3ea9c9d72c4ef304564391c3ec52d9244691f9a6c65f3da2faef4569027df5e8b8e57157060d5162bc7b09226e9c7ac7b445f1a475f2250693ab18b2e2e4b2f51929b6d569d7987663400752ba49d016750185df78d7d12be64eba9685eeac1e3531c8badf9dc34796cc5d16d1d1ff86309b328b1aff55bf5efed715e46eeeb562457f79c12715aa1affb86f0ed5d37038bb2f9cbe4a7e6bbc65f2bd18f5b9977b8f2f513152f1027a5eeac779e60b076564ba8486f3a345a40dffabb3d450138fda9cb854eae1c91a2c398c66e3570d78950fbc31197c16c50f7d54aa5f0ee019fc5005cf33c097d6b9bc31830ba178b5dc20af3c93a6a5a15170e8980bf98758b66241e1f500027ac5f3336b2dfc18947dec080918ecefc482f7db9c47cc32c3a6dce682380f6c1f8e6055c07bf680973a37f372ef3a573d88fe18814ae51e1b40591b29f887a5e058d6e4d13ebbc43f31bce7f3dc5c86e7bde42411d43e427397a64efd0d7d6830e364c80664b808ee746f8f7bc98aa42716560d8aef0081080b27e73c7b7f1ee6ac5baa535861a0fd9c629998e70ef76172befe9ae025bd9cbbbdd77a01529129fe6b96f61b17f19d438b9744affd2da5b6b859808800a737a13b4a79feaa4f5494246435e15e6551f1b41403315cb44c8945e4b8a5fd7eaba745cf4ff38b675e7a3ec1234b8ffe14d3e6738b75577a7489e200f65ce6ac3bd51f27c0f11e52cdafa3d480ca81ca392ae8271611cdc054b6cd45c0319970e2903d0b0d4be114f9c0d2f568f2ddde28765149e5ec5ac98e52532ed1ad185b79881807752138c4cd552dc6ffa54187237d53ad9fbd1415e5f63b38c23a1e05f89e0a31db2556158e4af0494db6c7c04d53375621c0bdeb49605f33cc4c6eeac10577c534567933fb60d84d0801d0ba470a5e3afd5ee8bf24977656061591510af8b7892d3497bf6f7e4391a45e4cea5ad2b515ff6cec15eda7da350787599757c2c29079ca4ab99b34c5ee3b3fc8ea360500a89613f0ee36e408b4e4f32c1f21f0a6c7288cfdef6d54e638d091b39ffa51fa21afc948cd15f9e1a0160e3a795dcd0a992dd685e555f4d5ea82cee52c23761b94314ac58477e9a2cd3e5f4ac6ecdea64d4ce3a0ae247668907e9babc9685eb294b3330f7647fa502ce53f4a8a2b3b2e740a9ac0bf2dd5a9ad21a6186ddbd9e8086cf807926cf75d08f86724316d049e09871ec7dde6281c4e95fc10cb7c389cbdc7987e6ed0c25e26db5397394292bb80db041a72df327662dcdc70a74f99bdfca6748308c24978abebe65906a1f196668a1e159e9224bd00df69fbdebdab563134d06ca32151d9696fdf813883eb1fbd258508a213cabc1ae6de708b1bca0e32be0f10dfdfb68c299f790ec660bbc2deca91de7e220030c0c7787cc3debd746e7846e5cb00efa3149106d611aa093c04535bbbcfc3563d8c859b9bda9be61f7cce4714613a3f7d0cc3551f65be744fc4a90a5f35f5cd4a286c19503d023e703581ad61adb28b85314afd94191364c61d666b9136e757a12f8b45ac36e78c0a29619423d0529b841b7a145f93c0364d4d9b766862057fabefcc8513f245095f06bb5240d1467950ad5edeba44ecdd04f7e96c4275f3ed4eb7f8ea538642683c191bde49f0279482b2a8b6a4d01d9f6b27fbb83fbdd5171b4fd4615789df13d56db411913f28c6278fdf6fbeb2501293b98498ef74a2d6942881a7179c611eeccf14ecebe707d2b72ac7aaa79d15a73ecf1c09b305efb38665434326bef202c00b5fa0788eec91ddefb2a040c2c1481e4156f3eb88ca019f5d44856e51cfe2813a56f5c0fac8471bde7fc57f55595c44bca659ffac8cc46a64a6e36720cc85b671f49e3968fef2335ebb901bb288faf0bf15e3c42834d72df3216456c172af33d3c64b0e8f5e0c2124365c2c6c886ed048766b67f460c1d997f58115277cd07b52e6d717ba652bcb56fce20f2d7e1c820795457ab652ac1477cb5c280b491db18381bdd89726edfd42cb7bddcda498198f06716c816ccf0ae7d298c6e18fa8cce9f108423c38501e799adfa02909d2d8ceef3174f252428c5b3211114179ae256d41abbd47834a16773aa88c5c57cad0489759b56a4392a0ba120e42df2445d14cbefff6b719d14de3862a217a1334ee411bc3d9d0ece107dc23facbe2b13c36706d4547a73ea66c147b1ff481f231c3cca20ceeefa91b0a326b06ee805af89c8e54c52a878ff869112a5d0491ec3f522b55b4f5f1fb8cf41b7b777fff30928dc315c8e28c55d96d40615d8118fc0831d3dc8d1124eeb78cdc5c640828658d32cd795188cadd02aca2b7aad4fc506317430e1988c4c2b981ad90451b240b65cbc5c055ea807812a02e6d545f5102e084296331f82e7162d94d87c5b9b57b6197b5d0c78121319845dae411970bff0b4ace856ad49f4b68a04bccbe4d9e91fe1dfc54b7ba2cde865543dcaf7c49a7823f0895402880b810d11c51806d1abbd1aeb2469dc8be1b2732633c405d7b542b731cc4b0d5cde1389f829c08b14edb35f1e84a89b828839a23e2a4cfa181bb2b7c654043c07bbfb27a11ce7550f0ff977b94953d0df0d2b63d2faf82923c8ba109af7510ab586e7bcca067c778037cd82d05c17be094f06c15e8456fde51a52bbae6b58336abb59613f09fb69eca8efc1cf861dbeaf6b278dbd57af684e5ad68d4a830ad07327e47641ab94aca7f26794faab44912af5a11de859f2af9c0a108a1526ea5c3c7452d78f7c8bdf8c40ebfa31cc6556ac5e8bf52f844266f059467cf45210c460b23e29c0e82945d264471e9262e64b2cfba22f8963a7929e3685c9947ea9763213c33985ea389f9fcde53470babe0be48a6ddde4683cf10cd608a66b257895c2b13da152fa61f5cfa135c221e440cebb4030fc25bb56debf7da217827c4794a3be215ed23f8ff20543fdc62ec916ff7ab0b72b5b3472edf2b646f37b7e470cabf637aa2f1bd11fdd6df4f8a53bd8377f5bb99b3fde7d4110a076742305c914f914d52addbf4c1e7094ea1af3810c5535a67d75213dd87682670174f925b86cedba0c87e56662a3e8ce4203262652bbaefd7d543afc27cc0425182c1a77def94d67ab5b37056e2c815ba88a8d8eb56467ec6d9e99bb68588e5817dc5f7462554d418f08325a05229114f3139ed7dc506a9d23ab60e61be7582830bc38f4000801f2eb5da09f9840ac31118d3d56406b33fd4580af933c834f0a430876d198c227ee5f7762a57264859e15279ffd900510f1ffd7e3c9eafcd645f40ad87cb5bcacec832d506e16d1f58607a56d5673c01ff86f0098e12922af254fc78a0327791fba446a042e1589ae833b18ca28e7092d7d59ec38f8d9a52a60cc347c6e34ea568903ca62fd86a389eba205eea7c3072a87b89ca8ae5c553d8aa6ce8367d3dedcc12c25e3d3f6253d0da1077bdd2e3c970c067372361a726b5180ab6d8a25ca3600f488e7941191db3f1b652e3a4dc210233142069a15b6bbec7e6a32de17a459848764902f39171351a6a974dbedebb853befc8cdef051e8afd68c32da4a01ae626628ff30e896458aa33cd94b8514c6b4ac7f9c692042ba50050c10b2d281def52d6b6209c1942f048f58ab24989102f39a9b87130bc3f59e672521e8fcc529621298c509d6273beead10b9aa71681c8eccf3b49cb4bc445fb2428152ecc30786272a49d8e2014b8fc5a7015c47dfcdb9cd4869846bb85b5f4a64ad63430669e8716e14df9665c05eaac5e7c540cd7515b3675be8246305b77dd56f2b2ffa2501cdc16711a87cfa6283271d4c48d04d91cbe3f12a7da95e0696c1fd9168060ca94f472ee870006112c8a38ea20dca847215e8cdc66082296ba46a544113feb88119770a83b4beedb8b0ae1f8218ffd10422d3ed826fdb494b57a3bee1c692fddbe3992f9518ae0353c6f6a9d940603efc10c50abe82f2dfb969a956f8828e8fa4785de9447b66cd22ac033f68eb6e6715373e1e44496d98e063e2253191cc058f58a2bae51398637b7dab90fa03770d2109305502b377285f0573a992aec42ca16b68ca13cbfb43a2bc4f6f86bac7abd9683df4b567db38ac43315bb6c68716586942615b996cdb5fd6dc12a9b115e043f6d28718fc807e441c913fa7f1a6f4075f51f33485d5846e3acab50b39e495e388cb4e1169443a297d388191eca1d9126249bcdeb084c68606bb906bf2b3fcaa2519fd087b3bfe8987e89a7a541aad6617ef3e700ea92c761e644599186634f76121120c8a4ba168748c68837c2a19d81d6df5d5e74cb5fbb7773b184052252cc42c091bd813650d6f912def77dc1a48fdde736903651a81c396c06c42c90eda76ae54f6eb0d63d50c757fd90289b2cf0d893af38a593d15a3e1256a67acdd2fe1f2516a89a4ac5a2605b17150270ce6ecc6c1418402d8068a2c6b75ef5a13a1958052477f0da5fbd93d5b139319772824ae15b81cd42dcabbaa7cdb0f9447f065d2d9f76cd8bdbe2318891dbc877f42da300982ae84069fcb3b03431536cd6bf4c1e5978743c02243177807492d3fa6af7709a1c4b76a92a1c35ee4459414b7e28826fe38877e25c652ea1addf40981fcac980be54640e0fcea84ae0deb7a5fc6cbbf2c7150eda8e66f0fac138f7ac6b8125ceb4325ceb8e12aede1f4cc4ea29d1e75fc5d4f561497c606821ea8a887f78af57a8577db1f1d8aabbf84ce26aa53589d0756c60fdce3a73baba95f036e281958d8d1ab628a2fbb1052d5958ef9205859fa78b95d78eb21f0ae733f0991f13a11fff447d4f2765caa4bfc41ac52037ca8a9819ef93c2aa84e5e1d226421a98181e2b66ff72cc81150d1fa62cb329a189ea45243a9e8fc6cdf500faae53db890575c077ea3c39a487904b6712f2a2b53a1e674c528c6d142cdb4b2b75b98f9597a5782050b1478260a6517753203e43042bf9e5d185031b11096789b384023af15f2240816041461a727c09fdbf448d6f4586a43e5a94344456223e6798a143692649274b366d87e6dfc68e3272b21df4983f649047d41a8624f0f9e4a7016b8f90630e01263fb067bb3a0ecc1b6bfad6c3ea93c416da18a0979179e47a0ba1889cf58116a770633fb5eb2adbc2bc64a9a10fcaabf8b55a56713de9a6ebb2440da9e80cd53d27624b571c85c38daf2d677122d47d602aaea7e3f8a6bc7e0044ec0ed604ad34150b9ddc42fed8ce0c2888e3cb080198d8149aea5bd807c53733c162fbe997ecafad965f9cf190431b1683e804cb3ddd4b9a6cb8c1d75ef58c906929c0237585bf137c6028234a089381e4d646ac1e1d847004dbf59b26670e7fb50cb95fd0ea4ac7e0b9381e94ea9e5cbb772fca62971ebb4279bd91cd7fcfa53f228e93cd547ef28905cc4b3007adf85ae06578616e6568e1c62649727abacd208096a01fda54ebdf8ed8614d2322bd1e4caaf7cc009001344cf4aab6494aab3e35c8efe2391f23f7c4ad206b5da1b673dc7b4d9e644a6cd3a6e67aa90a0fddd59450cbc31b5ee71c88c774a338f270c73eb830693ed504856278ff71d67aef88a039e7d6d4817fea7b8e3f13ae6e35d79d71ea095a789730aa8d8ee7bd5450415328090f791985a93a6356e25ed9980b406235580f60041d9003e397a5c91d836a77cdaef06a7b42a6d562e3dff7afae131c7b556669f6fdd024438fe59d685f2e1dd7f6c8da3f0955b1f495eb8e3194611d7e5a543f6bc201fad2bc2ea2f77bfaf6750efe104ccc2ace36c58171351359bef9ace0b308d5c79937209459cad1bf61012fdc3a38d18205a7c62092588966e44170dde59912beee70ae7fb3353031df63074692aa45becf6b343686f60fafe77bd96a597f6f5613079ebf4d175ca7565ee1ddcb557e63cbd8cdd7f59ccf4daa2ae95bf1cb922d6458479a8dca61dd497f7be6c1f86c06eb121c3e818ea91a42075b1a1c630b26bc043499298f82f43e1268ea92656df17a64076d080c5be14b21eee2ab0eb6e4da7118c0ba6da7a70c122dc7ea48331a2b62db0401b790edd85a4913b8ae924868c969ea50328508a4cb3c21181bbd657d5f68fa3eca71a67983efaa57f943451b2e7e2c545b9245fae3e3d80f9be5336e34701e92d0da8bca034054ebd7fc9f6ecce06f17b476d3638505d1a408070b59c99004a585fc2e0e058b7a0fe4c7ef211c52ac290f650976a2f17d2a7624416c6fad667bb2a560cc32f4b2173fb4fa8d49f820a89dcae4fc448e66e7d135af2e7adad0e0aae84aa05f7753ec6f26c6968544f247db41ce2715f099244f73e2505d36f0f2498c1ca8f429fffac0d90b91c450599c849f041aa5eee4cf180dae07f06ef9588b78c8382ddd471877f817a5d13b22f90e8d392c87788fed4aa48e38afbd4471d55e5261b43f47d017a07df635353e08408b00bcd9425ee042787b097e6f3fb0682312530da01c80b90bc2b4c19571f4c1e404a216cc318910b2ddcf775d4172315161c79657418b0cf06c8f6beb4bdb813dab4215cc4a8527eed13b2249e3b56b1791cd2472ec2740b7bf0d56f786750e02351d813a2bf3f33145879415cee5c175c77aba48ba44b40587fce17a98ddd2e3bdc271e04bb4ee7bd15badb978641d64592bcceb8467070e45034b439d357336e3b796e221c1e5ec90cbb2f42c4061aabed422589072f1e87ad868b8ba23c46449cd6b9f2772f2fabced663363beb98edead7ace16bc6a39de856b182ba9347a2bfd2568366953537ea12a84578df5480d6c155a2f8d6ec189e0c0a8f85208766a0772a6e164d9b794dc96ac6f6b48107992b794cd32677929546aa4da2c4d65fd7748a2e17086a301d9b9727233a07403c9298fc44b3c6dbe31f46fe4b9fa54b1a30ab61d36067b37f8774f9c54c96f4d4b80e3a79e88e5df983b77336ca0bbf5fcc53265df1e32b8975753b76a73971d8fd8578c1e7a941df3c74cda539cda12810227542a57790b85bdfe48abdaa7b718e93da3a431e8ab69a141634287da75fc5fe909320e5251d78b673a2486d4abef1a80e3963e3f55dbfe453a37208afe20177dc219183f3191d8ef5f4f5add5cf7995f6f31065b22cd78f52eea8efa8013f341ce91acdc920b3df94ba25616ea57667e299fc633ca09645238af20778f32f1e775ab73b792a863acfed6eaf7b5bae2f995189d472d1d692f68eb36dbc3ced4c67a1e74580b0f2e5e6b4fe5cfe5a58d2f8f0d3986c9abc5db44111661607db81311b6220f5846f68ab559ee05b2e0a123b418a24e12d720440b225d9e79011127e7a1202ed906cac5022e790527cabdec0250bf6ed85197bd55741c584452080e0da65f5f7ea4ff376f94051c91b837c6b9ecef3f7a559e8714d1744bd2e9a026d844d26b23e7602732a6ed1c4ced54818d6753a74319eef2a76546c733880491b29d00a6347734a1214a83430b3aa4ea26edd847787b53c10eadc760808144f7bba81b3e22025f66d61d2147843652a8b6572960d313abd4b5f6593d89d445b56b2eb9d600cb5e273fa10b1804becbc4649b093a6ee65b669c81c46b0976eee845e4710885e4b3ee52e92bd7d1a9f022f49865c623d2e30a995f55b03aa3bafd4365a4d28408f39444edfeff490ac525aa4ed7590426b56e4a5f8b318b2170fa3770152c21c67b42a05d9ee7bd21f4426a25d402e8213a417eb957c60fb78c55322aa86664ea7b7e614847f6f150ae445426a044f434125593ce373b2505af317af7b684f7d8a6a93e1dee4b9b83f183ccc3c145d7cd197db6eac7c77453a2fb5a046c0be9e82619a6a19ff08819689759125f36b0e61dcdd904c186cc76a66a8d44d49b96dc597bb8f77eca447d6d817e21b57b314db15d2a9ef6252188a553c36ed08dd32367e4b9779e8ad4b392fcb4d8595687fee08b691295ad120e4f80d5cab632e77e3c88167a5951b45ab0f2d72324db87fc1238568de89c9c3a8b6d98de02d12f33994f208bed7365126ac136dd6641f824fb74e2bdf6007fc338a870157c8b15526a07b99934bd437ee6eb658567b6fc32f4ca1f08a6c4100dcc5ceaa75da314ec2606f479bef0bb8303b13767ac95126a05c6bb7670e1d8a435f8971a0697c9836c3f94f68884f9f75ec5b36838113152addc6fffeee0d1f305f7870d2484b6102be1b1bcc359d6a0fdc1f4a15ac917f7b9446cdd75a9fbffc88e614c07a51e6234e0da4f6369efc077e4a191d705008edf52deb8b4e2fc385a916aeeaf2239ea076abfaedcf5ab9ad51c352ff86c5bb44ef343d0dbe2600c871a058235f7ca85c817f22e58b805fa03d1c402d5e936aed0960ebb67e4009d7043983c158ff57e1fca135451ec6756a709877d92fa15359f88f928bd6e5d1e1b219c23944f2a1efe6ed7b1daf968abca47e4750f49380498137e3ce946c25f0daf435bcb7f99b8a6507d8a6e6f34effecdb781e44668657180c705cff7b01e75e2551dff650d7dc3ebbd1bc282f4e3faff4d95b275fb43df5375f18b075360b7d917c3109aa6ae4cda4460ebae35a0925e04d170df8426db303191ae002eaf4d1033f1c10e71f96d65c2bc515fdae26dabdf67091aff997f4d751d4785868246e86cf6f","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"38489ec2c4b45ce76fb13d9276e7560e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
