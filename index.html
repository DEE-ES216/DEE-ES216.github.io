<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ES216BB - Protected Evaluation Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ES216BB - Protected Evaluation Page</p>
                        <p>Enter the evaluation password given in the venue. </p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d88eecc619c98ded42b3646d9e5d41e9c4df55ec1436441876189221971059d8aa83c7251e6f0679a4cb9b9317e9672c83b86e9e82701b45179f53a43e4a0510cdeba2a020969662e3a40ff5f73880fe92c14f4e06deed0eec93b5ed9fd3b7a150b91967eebe0da47a2956374ebba3adb162fbe2f3d7ad8589a4d69b678039014646f3541960e75cafc09f052882ca4b142acb303790e018cdfb1701d3f07fc50a147deceb447ecc1766368c0ce037ea40f29bf3a5ec091cb62092dd5583b6b5255856624cb812907facc97964964d33dc6348b8b99628ad6d8a29563871f6efd37530137743d741dedf50c852a0645291e26db861dc177787f77d0408f3524c2b83d2c84babf1942f16438a71eaced15da9450ed1fedf4b0e7c3f8e2c53b79adb9540e83c68cd5da64eec4c1ba3a1012de4a25f68b5f12989b04e57034cd6a322a2738d265eabf426eac073930285a9f0792a3cd21e630f9ae2d168f366b86160aa9bca65e1b238909bbc6c2fddc0dad4806db173cbf8f5d7fc00a49dd005c3cf42e4a312f9fc1b3a1132f985b1cb795b62af12a52a66449456360372b7758158f426ba2bc594417621dc0c877bebc1deb1bb819925c5c84567081dbae2ce9373ecbd7f2f3833caf56f6a0de147bebf0d0dea91b4c23618e0c19c90e0725693c590169a5c771b2e0d1d9b00f6a2969a70b204104e2a5541b5483af3c0138525ffc077e19f3f605e44b9669748f315d739f074ca2d76d97b964c8de8598ccb20f709f8e876d854515330b93e69e52fd7f19c981bd3c9fa8c4ab0d65a58b36f706b3c51cbe2990eb0aef51baa6ed74821c500c51ef51dc770fedd4a2973de32bea7b084ba6ce2aaa755aee4916d454450d0914237c205b405a314e8a15427f1fd2f228df1f2f2a1f4f6afa645c333ded46db78e6fd2d4725b9192898753a27cb0da1dc015dd53ef09d65a5e17b1e8b39c0e7a5bb6ec050f3efa44347242a586ea26f9991cec88a8a8efc79c100f123a43e747a5e09bc576a3beba6e4f5047a5f8a9b83033430431f9599e2044e6b0c062b14d9dd410342476c288d928b77c17357763158db1e71f94eaae72b4c25da05e010e43dd747014240a135c9861fe1d0942f9de64b2d70ce7e3163260c50460fc725d43416e0bbf06f9b9c6a91a2aa512865a593ef6e3f76bd172cd20f6fb3286a9c0755066d270937d37a78d3a06c75a2030904ec04aa105e10486526ad7d0477422000f4e8e043fe89412cd3113d2c3e57bea3c96f66b0b3b21baf3551d748b02903487d1655f00c0db5a65d6bab0bb5e160c0a00c7a74884b75848f2fc27b6117977a472e1a3869c5d529f6100af504288122df3b6c754a3cdf29de005b699aaa4dabb27b380bb9735eb1e00eb55b5697773c7fcd23e9a427f6758ea12f5aa4d646492675aaae481323f80180cab8189e37df5f9860284eecd443da290319b0adaa10f7017446a30b78183d922d29f8d0361cbb5f6541cd15c0555152040bd881682f05bcd009dac2eb28766558863dc46efdea9aa35b47056e0fc572119e831ddff9e0556673b778b5fbd8f016a7d912b1c8e0eaaeeb682e69531546dc3e8fd928f850b83f7bffb8db7ac32e1922eca1c28bc7b1e6487d27e38a0359c00a7970840db4401ec0cc958b0f00d7b6fa82bcefbed849a6fbaa9d9e5819284d2e07974602442b419704c566132d33909efd4769fc9e2d7fb7ee791e50c7c1477fc0bf8015e2fc11f81d672c2342af9a22b2d6c142b533356ce307ae13ec093579b1ca6324aeb431bfb189c3d01da0201fb7d7462557ee9a7ce211ec124e321ba3220e7bc922a68feff7a7b1918092fbecc774c5d3d4e42630bd29b1669522de998c9781c35a37c1863362415fd3b4c7f362a0cb8a17867d3daad3e3c3d9956efc9dad6c15fa48cd42c042c66da56e4b381ededd9e0937e63fdf43c0b8129e793107f1fed84c9373cb86e5e03a72d7543920d6f7c21609a2f1df93d70b9fa252ec9940e129558c436cc120d93bad295f68fad65b1cceb4b371c7699177bde0aa72367fb0b1d5a40ed1014218d4dc332ffc214c8947e98e2e1313f3368cad10caa55c6071f3df117bc260176788c39bd2ee89ea8930fa47f7da9e9d81a958c11715d546de76621b893b6222a67ccdafb11da8b86678740607c25b52dc21cf5d1c7ac5bb0bbbef4acbebb937403fe37c9454cff8cca07aa4c051bf3d08b333945e664da8d207c897c04376bbeae40cbacceab510f5c9c9d5c3fc432ae13f5417333f9d8ff75e74ad4ca3b2bcbae55bbb0c6ff12c27a4972c7e2446100cc4de31f9d13bf569632056f64900b196d9dbbd7cd97b1939098cbd687465186a3579cf2c72f5e50d281faa77c68348ec4e9103207b5d604fd1faf126e428b7eff2b9023926cf824f502b1bb9cbbd2ed28ed490b6aaf95183bb0224cfa79025c51f925a7520ece5cebd83b97f0856aa94c997c49624f11439a41cf0f0277f24a1190acfe8880a25f3c4938eb028e6ac6f3305e22ccc8e528dce58057787c85227c4ccb75dc209ac361c5c79ed8d767be8471b923787c40225156f6724c033fc6e11747baf46833b68cebe449d2980cd82a945af1ea336afbc775179c64914bf6d92892cad31b2d9d05751086b390351a18515c696b50024d61729209598a21ba255d124faa4e20b8e882f7077f894b0523b555699772f0e82e44e3dcf860c984a694544f99d2336ff07be62f1601e48d8f1fbea2380201079f6ba50a2bd1f7c4777a326142ef6ea33973fe2a5c292ab73df42bb67fd8fdbbf3c797adb060a5cf7d1678f44e61310d9ab966f7cb526853f6d9087f2839c66b5a60cb63fb65dbeceb6983a0730e87324ced87220ef4d12dd19dd4ed1f361581401fa65d14340860851e839600298c6b1d39e2fac0ba12bc3d8f1f3aa6aea86b3d20a790f563ea7f56dbf592b17a08fefcc4969af17dfc4bee79857b004bab645fc359142f696c4df6914660ef8750e81299ed4541ddfd595774ed6d089a4e0fc46b34c3e64e23ef01a6351d9c33ceed492d83868b6dbe372e0506f5b2d5492f563c61bbd5cf6f45287bc7d34a855916bb686cbbd16a73f1b32b93ea84bb031c55408b231bbb9b4326baa30133d200f707f7591a3ab547f6abc61f1e4c5be61b32e4d2c288f70adfc22043195274c0636eeccc14c9830ecfba7d40aae09e82b0f2932f0fbb2de0ac11dab3fc22f5bdd818d4fca613365f991b0ba0257c205baa94a4be57bb9a99aca22c406d2e09ecf56688d2f4ad6d1bc3ee3b98339f19b24ccd22c9f3ef985eb1060effa08fbdd2b69a3c06c52b10117ed6fb279cdc6585ae3f734f2c2dfd103986e65cb6b7af458650e19b690e5cfa246e82576f76957b6e4e3736e25ca02dd58990b2b3f4f5333651058b9165ea2f7032f08c7f18301182cec88f05a55c8c605a857db78d2309b102408d5c365c121362e2d46d9d7a5ac98e062d11f2246fd0015d50f3ce2730e58f25f6b855137423d03a72289364879a59c437137598c4a71b1f24f28f3fd4a79f8df417041b026bbcc8af8e8d947eb270d2d173b7f0e643bba326411000eff219f9a46f032d60a2a31426a618a5019e5e1f261ab80cc6a913f5be58a8d2716d3dc77c80fe0a6041bfc8ec829fca2f01d618140b4d5311d03b0cbb3ec33ee98bbfe33fbf606c59219e7b1206692511d25c5783de20de6b83bad538bf2c0aad444fd4e08ecf9911dc1f13623d19cda353d4b79b7c09a65fb4bf720c1841ecb4c6f7b7671f81615e1d21d75f83597aad8f9138758ff8b9912a6ddcd1430f122c32f2b52775713904998e2dcf4e8017693d84cca17efa3bcd5312d82810c31ca6c54a82b56c4db897ba265e3e24dcc67e40576e48a8667d200fd9cad71dfb8ebeef7e6d04e476e72b8ba66f5f72e3911ac8efdf99b5a91ad7305811098ac30e63d867c5e4bcc820d457745d063ad62897bd554ad68afd3c1e4d025e1768f5033958b40ae6293d48b34fbc6092532d40ff8c96fd3aa5e9df37210f397bdd84ceda3584a9f29fe594350b0b644a2d94c45bd38b841b517751c3fb9bf93fca0b6c70271758c3bc8d8cb70c7c742ec482d32cd6c085e8bb6936e32da63eac803a4dbd7220f940325fc9d992d77bb1ceff32bd182cbfa995406acf3a3c3b50a8955bb440e554cb7d7f417c38c8e3767aa203082eb6fcc02faad67919f0d22c7b08fa35a4e806cfec789415e80c212dd09e53bd3f3f5e9c6f61e5e2341cd3911fb16f6935fd9e7a6cdf6edfdc3d2fcdc648fa119e47b6e2488b85dcc93142ddcb48659d3d25aa91b2b21fb2c18a0265d1929ba2032ed4f2c31b0078e3495d94df259cf53ef7873fad8d35e0ed02c0db334df57a04cbbae7121a1482329f47c37f9ccab074e2d1202f4b8ad6035ce7498a38751dccc4e97107e055d0345104b680a1327e9d2938b485f5939f1ace6f32c9a3cb5adbdb5ff2ef7009e8e21e18d1bc4a409a5337f1b0cbc0f5f82e24e80ae9dda1ed84a157222ce3db76854cca965432857f6072cbe2f926b394f0ae76b2f3e17efd0c624d2421ecdd55ac364ee0f7e398945f377491772a3b696911c9323e39b423bef795b1ce3b3e590fc506cef8b2b381252b6ac007e64d426c2a0479a8a51e389fc2518d6e703543e640b55011af852c84b718575b7b98060648fde5e725818760040845591df575a9d9c1d4c62c48b91c454c5adb2e07464b090dde79c4de3160e5db9f2d22fa669dcb49238e5fc10d8c928baa7508e36384f04481a775460a03912bb4c10f3db2131346354f02fe2acdb57673b1c4b920a20081a0989618dae8c4bbcc137069abcee6d4381eed0bc04f57bcebc4ea86dbaec0098f7c9617017cfb693bebdcbbe3211927a0380bb5c6f35c9c432c8a405e2fcfe644bb2bf3a888250c069b379220b46f0d2efea38392197148b9ea8ad085207b7d8938a01b92e07aa08dee1d4d68a9d45d301e82d567a99ebdcf1339caeb4b9dca8856a0e45bd7e014c8d8a294d7fa956640d1aab44297cd7a538d06bc0704df50f7bd5f33da7758db934079ce0a3ee32ea337fb3283bafe415abc86850d1923d335d9b8ae46ab9ea21336e3cee74414608c48156aada602d2fa309e191cfeb6764f471e8b18113143fd14680503f9a077306689ee75f905b740879fd83faed67e3ccd69da05109af5c0941aa5b6ee89f0164dbbacd32dd3037d662e96868f5ba237a8f70c1a9b6b63fb12cbde80fe20f79f0abb69a40596b68dc15f7da780bbc27d349a7458390d38d62b57d430d04f6ca8481b77872640b7e209771898cc3f9bf54a492a7fbed083e19a09720ed0da633dae2216db4056e3c0406cb3164aff71620d63911431e0923e599c236a2b9ab6cc1265ae7341875832eae7b2a0077163eaf8ce2b142afd7cbc74f5b059bff6cd4f572a5f9b1fe42034ce75298d11440a61190860936c653c7f19e893ffe6c15e338598c430c31fcf3e58fd8eddd33a57cbde255756b24589d26edb6552e678a7e965dbbcda6bc48d7c49f9887c43c6420f909cc5cffde57444cfaf21a8fe215aeca6897b1d24817fb64502117313e8f93cf6f1ecb70e6b525449c4efa15bcc26dbe1afab8ef71d4db80cc330ada33313035afe9dcd1b51ee861a74701172e0d2bbf34b625670060b8e2dec39f38cd6a044c3e725604aaa15e61877724c797567d9d6955ea2098c48029cbcee89ba45cf3436c7facb07d8cae076e0ed83b4423103b759956e262d446283768c2ff44ebf7e4f9264832ee3daa9d675e04a54f08b2773662cc60ef88694de1d4dec20655317ba466b17eeb75f51a351f289a0ba69645ea6f1744a456667342dcaa7f1f4f03aa9b196b08f45778197470eaa5aec5e81ffe02d2879703e5a7f4b2ef5b239eed07891534e88ec9d21a80533e8a083384e47a503d077ca31b14fbc270ecbc1d3bfae8eb554e95164f3dfddbf464259c706af4a8e88a1948a8f6b4dd9712a96277927fac6dd25aa637e4b8a757dcecf7ce74fc31486320bf3951d6b4b2535a01e8cb80394f1a1f9a9c60c4cc3d134420a60db8d816287549e5c7a1abc798c646df79129c923a56941bcbf089215b936b97b5c7862406c9c6398ad62a18c86f1ab86bf1718061ba3a263f22b1ce6d8a3580a8d8cc1c8edabc4d2d19cea7709964455536454fbed90be2874e4b1238bb0f9b5335cabe63a3db1a95d28e35191411ecf640c894f7920ebb603749186b138d52c11de1bde580235547f9da3bd71d6e6a2c47bf760971079e0e3cd7f2632d3d48baf445bb0c174170ea53a4fd133b0ad5c22f8e13ec81beaac219d6c62b20a3dede0f4e766045696eb00a522f3721b761ca3b4e3606567ce7cc1fdef5a7ecd28aa7111d033820c76aa5ab87871082a5f4e5f0860cb633cf7700c5fb5ec67547f8768c62814f480bcaada831ccd957062a3ed1f22d9e3fd34e26bb5b606927e9af2c1c2d7897b9b7031f604a636d5e07d26f2e15f630afeb919e42fbcb1f11ef42aa92bce5c17deb33ac9935196ebff2c7cc2935580e17f27606fd21b0e0e8ac0724fd9fe0809863f42bd07bd1b3bc8769f2900ba2e53f07b483b562d0dad27aff8af62beb1ceaef9b670d315a7610a6a6c16e464feedf15e79a7e7de27a530a5e930752ca1f51ed0b58852132af8f1d4306258bcf99f7aab9c19aa8b8f33ad4a38c71fceaae7d0c8e84c11adb9649ce1307c71a47368f449a2efe3e87d695d250046c03e2af1922375f03bd4119bb2b51f7984c29cbf4eb887c6f2e101b6b60f6b5c74c6d478dce277c4f59b56ed355268c7185991a97663112e9f0d3b06ae3ba5ed91486ede6a431cb1d946c8bd74abc55b7dced9c4029520876eb15f40e7c303dea1ca1e172a65e257b27b280c673e44db26dff22bcb05eabf9fad4426dedb6c7fdb5e9b8117cf0315e1b3c040c101e8ba5bbffac4bf440f079efff9e69f7a598a3f906c8c178825b498d3aaec79eeffcee7cf13621b74704fdbb8aaf5fe56ec9416a715c0d4779cd6f84d6e485676b5bc9f04128a93e81854bfd41313f0565cf77c4205a69ec51ad41fc54ea2f6d240ec121ae5ee33751815caca01b966cc709b716a718bc31a84ca4a43fbd8f7f080b682ac6eef89a2bb19a28324ae491adc97aefe9dd98f1bcc08a3041b354779e0eefefe5297516ad59631d83b9b88916cf8b9a6c1eed9f4613432ed27721a6329fdb3d40156a333482e6a9150af66a11ff28d3a33a54b061a5ac64edd9de1cdc9c0021215760c8c20dcd454009f523012fd520a8e46c673bdda9b8097a817bd3d9a7762446f33577b513f57f67e2038b5a83cf4a975a685bc8fbbe8acccf31030f86e7e3732e49e86706d21db4526241a291cb5a9bf08db53aa0da5a173217105f9b2e5a0c2f35ea6a2b4fc7d25bdd7ec87a74b765991460a0f4e63191b2352c593ad172131fc1586f4bed29ea7d7e9af4a44fb53a056666a391eec5a94e7c8eac5be75d363e62855724edb6d25f1fadcf2f85d1f02b50efc8d4f617762564930987d319e775f4c96393e5ca1a449fa9daa47a9fa34eaffdb4c8b173a0cce973e0da3dc21b246b107e570a9187612127a7e2cc2b9d3ef057b4d8837d75f863aa6f8c614ecb15970a759f2ea152d36c3f02dccd6a14c0392c4289b54baf21403d3e15b6d3261491b8cf516fb0ddc39b132fed55511ce4bcdd0c7512ffc42787291db18348ef925fb2e4fa80201cfc8bd6b2f13d551c2fa766c355d927dc681dc0808c1b1fb95f433945de8561c96cb41dc7e484a4aeeee351f1c7662acf37f807a29e84de1965612c6a6cdc07462dcf22a1fbc3ce2275c6e0e080f57622e035f0bdaba7498510cd6a9a221791aa77855fa7448c796b128fba290d48a94644a77616e7f9c0fb0728d2bf1defc12755aa722a44ca930436b2eee2d67f5fce141385066b69c28ae16b2ed16320ac239d90c3b68e56f3b9107236d9354ef78c78c33ead4f6f12d75a0d5ccdc5e00eb4788445033d8bcb0fa1cb0d551845819d120bb1aa94d6ad1afde75ea6e716a0e96a412cf574fa3ef4768d04d7a4064bb3010f42ebc44db2ce494fbdeaea9dc416e578065c557ebe45aacb37dc5d3769bad45209c9a48c5c1fc29cccd33a4d1a7e1ea764871c06513e71425595dc6b5d98af8652a025944db809889d95e0b1831ca94dc729a00808b71ac29778923d5fe89842ef29917c7a7f6da170eb613bac7a23272e5b83659a134de4c82935e976f03cca5e2bb471061a93b6d7f8bff7ca049b3e99192ddd30efcdffc78d8ca5df188e57e90f47f728397e78e48b9fd4a961ae28f3247f93eb0d5ee372922227effb8a46061e28f74a7701d35af210e36ff9cb11935681ad0ff0d57a6b744261b5aafee1029288f5ab238a1cfc373b1a489cdca16bfd2e0fffabab680e9e120e3f040af3f28843fc7955575f204aa508905cfebc7993091d35eaf2e06a6db030c0f32ef5abb73f3ea1750bc8011216eb58864793cabd57a6aeb34d765cfadf88e291a088df937069586042e200c5b2f79dbe7f5973c43d8027a7dd271c9a197136795ea3509ba560af5bf882a5200beb5bd65c75807aa7ae8f57ac5f866a299a865158db6be37afa285f635bf0ad1be18881ab6dedb3084d54c725919cc0782193842421ccd54c6f19439e330396432bf1429528cb90c2b91f52dbaf3581f63ce75ee171cbd29162e379b6224604c539b91737c1444ff195a715c0c2d91f7a01841d8c148a8c3a87726bce2397bbf829913dd2cf4dd2dd2516a8881592ed21ae21c435a4b0056045e79d4a4ccf3fc9df5b92610206595348e4568bedcfc1f805eff9adf76a2f005e54f4998d86852fd8687b9622b8b79dfb74de02248fd13e20fb0c55722a462496b82a9746fd88dfebc0bd7ed6192f0852a7ff71f9c075f819d5f4f7087402858d11c527f675bcd4030ff89b667cb119e92f2a00893d22bbac4bfabcf64c49ec6c220f0b43ca1163b946bcdf6957e9d42ed4483637bdef4b295c8310f3f292f68bb534f2951ee46ab0f16d0b68cfa0dcb75aa47bb2a56ab48c57f0b4eb277db5e6cb96af7d45d2dbb2f9eab2907b095acfb15af5273a66d55d2304c3277780f79a5424e6d43cc96f8f59bb2d5c189b0a72d24b832f4241a35e7cdb7d32a729b248f2a9e4f1f0f88798fe321e15c9af23ce9054e28de9a1a29a13b7139e28d652658aeda5da9e8205211b6949f0a054ab02b2c1c84647d34073dcd816e3fb9839f8b8561edc4c50cf8d1364a8a9dc2e497f5980b4af0dbc6fa4d60900f25a667043c1ae991b9e570eeb9fc086b56b9c78c3d5cf8c1190ef68ffe66866d2148c6b8a862911929eaaf2aa73c02b084532146e599d1bf74b98f88ebed156360acd8acd80e3eeeff6aae646ffbcb52ef1e68cd85fd1f6894858328f63d879f8c964089fe4fbf299ec42dab6c0045f014c1cdd996d802a8b526648479030a115bd1b786ff32b61c14c66beccf7d17d207cf0c1af44413896c407394ccf00dce76c2111b29f7fd6413d6427aabe9431ca14a4467787788303c1f1c2ab338d9ac2276df2763740ffcfa9e0e1b8729c9ac092fa8139cb8cdff1a52bd0e5781c4d15e0a8f5f7660638e97b0c53f2f8eaea0133f46fcd03490fffea15abad82c0bfa0652d5ebdb8c90d146859b640fa68355c45e56769a95a40e4630eb475106f0d51c6db5a3f7856101b470f65e9b0aa63ecc90ee250348e9013563d95199c228e81e1ed86ef26cc10a9a888233cf7da7848eb609e935335e578bc3b513098eb48f69fa945d7505742ff4493c1fb15772798b4f833a0b82021671151ac4d90ae71623a43dab9c188fa60d30b5e361fde1fdf89a277b9d48dafda6d1f9fb2ee86b9b60bab1832161c71530145688444606079603e570560568d1fe02febf14785c7a6f7b075bfac91314d00da6ab6f9b53e1dfc638099dd2812c7b36d4674bc3aa3af672bd453e40ee45eafdd8b85c8d886f73099b8a70cda0e2b93075d46851bf306f909a8236b70811e2f8d4bf60cd79854f58be695f4efd86f86484132d7131d64027348d4aeb26bf55bbd13b35c454262a70d0215317894d91bddb13c9dbf8a2498a1dda409d2b296f1dab243a61a0e71cfb92150a61048fb72f3b74d64bfc122389f9992f0c3298134ac204058c722f2f8d8da05c3b070f055b428c7d2c9ed0f816d23fe9d116095f2db207f6b0c1fabe1d583530d2ccaac839889480657d603bd4a35a1058df171c344c336b40ec6ffad445289cc65c7defa0b737d135e5bfa09fd7ed16d31024fc9c53b41739cc7948ebcee6e37233b8d059be6abcb9f8dd6a51579692b4f96dc6fab81b6d672b03e31e2b3a1200c6a1b6597551246497ac991cf3d01b6dec9a67af7796c67eeaba8700107f7e9c71a9de38d396aa66fa6fd5fdbd5cf484dbe3de2893ab8e71b43ebb9bb0bb99eca518f4e3486fcaa3f5d3ca2c6a783fc923caf0eccdebe2a9b484132fbfb7f","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"6a6b54d82b1698f9e515b42aa2fbca69"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
