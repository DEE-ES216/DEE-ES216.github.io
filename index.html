<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ES216BB - Protected Evaluation Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ES216BB - Protected Evaluation Page</p>
                        <p>Enter the evaluation password given in the venue. </p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83a49e3248c7be4bacfef7e9c1489d34f595e834b14964956b2082efd00403cae96cb339c14f850965a3379edc82ac0f45d32140f77ab2cc201f4a2bee2f45e1902eeed5891240049c44839c321a2223c8440906aec47c2dd30cb0e72e567d9d28c8a2865cb3a47fdb78f28b3d06f1e2e356ac1d48d1e07128909a9a705bac1dac171241e407f6728fe7bbf740d5402ee849a73a83012f78433b1e1b85e1131dff2950e153de0e8fc146ab4ecb65bae19c8d7fa70e5593f1032d2e61708b22d995e285672902ea7f0b29d6a349d56ca68a2fdcf9568ec451902036b0ae4d682aedb3a178f90caa75652c56c2db11adb09004a872e4c8641af801f33693cdcde4125195be972e46a3d5f7e5cf36e15614751059d0aa6c7e2f72f75df31b3c2041ba8a57d8c2d23514db65a3dd1790683ad05dc671ffee219876cd716ec10cc6c3947bbcc76abac157ea899a8f0b24c5ceb8e2a323decf639317e1aa697cf61bd662f9d90d50b494728836e4fa95f14bd1e919c07f8b675d8242e0010dd9be46a4783482d9e07d854dd60be63610c956f1aa0f1bdcf01555d05709f8b03707e9a1a173fd2a60597d69701666a1c706add921383f6e6f847dd48ac71202322be4527ff497788fde226aae57c077c52fee982f8f59fe8aad3eb7e62553bce60258cf40e567c959669e9767fce80436ded5637547cf348202568cb37dc838d15d0f532ff61ccd63509e8f10e9117de9682546f0159b506167e1bac91229031d3b5febba0cd772a39550574c57d4eb2b107fdab45483a6465faf8d2f638d5141cbb38c0da63018bb9ed3285a0cc11453b9c7700489ce7d90a6e40d9184325b379fdc538bbe10e24af1c7f22b8828c681da0fc1c4734f2a34578e090b0d480a1b32ac1dffc0ea72b42abefbd0ef156ca028e9393b0714a9e16cbb4e13d07c13d7a7de7662e656dc53b79a9989a9e3b8bad4252783261e7a5651e18a2b3d4697b527ecc5f6fbf51ef3bf1d0279cb659d2d20398a8d82468c926441393ab13173485154bf50fe75077f89fe088648a9f825e9a1768343b4882d8145ad467397dd9b383baf48f8216f311e951f01df5cbee29e5a94c9374a9e1aaec0a7b2e05d936fbba1405c9755a22ac17d17c0c75fbb11fbfac395a8d53b545d5a2f049d08387abd161bb01b69bd758302329b10a26b5d7d60537c02e214bd6dedddb24dec8b0d3ff1183a1a9a2211beeb589c29a4f9063ec4a55c4d0776eaf43b1b0724fd529fcdf07280f8d9eef4a36aec77ebba28b4f61dcd748b5aa713162f1dd76887ff2f85f04e3cafcfd853f24845aca6b04bbc5189f1cfa958125f9e56ed209e7d376f341fd787e204c4387e99d4e6a605eb7f5a2458d7c56540f5b47df8e3ca95de9799b28ff749b619ff5a73f738dc1b4043fc45699bed6ed4742b8f7e73984b53190402e5a93330000767f8715cd93a30574244c2269a4b5faaf767b73383ab056e05bdea8436012b04924f43d78f4f34d6d7bc240a71662ee0fa9ca21ce1878be79e93c221d020744e2de1ec10267f3dd495ce1d33857b2df30e9f2335ec4011f02d2bc89e78142c35cdcd35e816a27255bf4ba28c755bb4e25558002edcdc5817ba2cf7edcbc99624ce2f13471a2b2deb200b970d5bac90d4697323d69c77cc597c162d9ebd14c90295da8bfec4c3335990abcb1486ddd11d142e359efb808aebeafd8a952318b7f0c16e3161e2ed6090abb21da856d8c59907b533db55fcb2b5be1436522af5c121e785d625c7954e20f2eedf9ce86f1baafc5c502692b997ee5794d6413254756ddc76f69d67ac9477a34455babb9da4e8f478dc7bb01f500d01e54a1922fd8149a5f29d5d3a7f6339247cdabca91050d151ef755cc64f133f7a8a340a4bc759d59036cf13f5e36c27210c89f00188b1abef02bd998fb665ffaea6cef9d580a636ca3ebf9341f9550bd630c7afb4a98ffe2da123d8346e95c90e87184b5400261f75e9fec36a4e728a358866d6111cf108bdd2b3019f24a353018f88271e2ec37006169ac544f16a3822fb32f6cfbc940a9469d0b072cbd8507988b370aecffec67092d0c2e1d3f8f45da5f6bb978f9d7522650de4ea0c6f113daee6b40741c219038b2fd0e124f4b8fa2a5d4ea3dfb99dae55e0506eba65415054f2d9446b2ec2fbf9bd735e4bd7204ed8c9807214daee06178437b925c1c9bd3e2c513d2424971d48772f29626796ae22dda9482f247128d7f3a04f4c7885c38e99f772483120d9af1ff8e2c86742ef06647cf148dbd75caeb19e9d021253ced486a1e1588f769418956c6bf20742d6a30f9852f3fd16de53d4cfd1a53cf17e53520238feb98dc5269faecc278bbac2654b54be4aa956fe3dabbef4bdce555e84b3a6f7e8d61d53411b9639039cde19bdf4035b29c21b32d9586f58d82c74f97c49521159acf6fd9fbac77492ea21dbfea648cc188ecf76c7e4d25589256114723ee701bef1008c26629911b3004061cbfff6a942e99952737df32b26b66d48095fb8db8a0b7310c36f8ed502c103925129ddd6428f6fbce01af88a8c0100e8033e6ab931455e01fbfd8e9af2d57663d6c458447c0cc3bfa7db6bfda08e27609ca4fe37e7f363dc78c2ee0218da7a521aa6c05009cbbfabb948ad347b54170f944b48f83e0d50d692db0849b40cea4927a5c7cc259b717b9253f997607c59ecd23ef2103302f78870b440102148077482519639ebf28a631e81d96d75de67442bc7eba214a4899dd8b059a057beb736e767119f44438acb0816ced4171d2dd48e41ba751753081364456eefd1f4ba88d009f67d8d3745a307e9c675c348a0c4f02ed38ee047801070be32f40c565bc6dade709abaeb71bad14a2e5bc6c88cde907cd1b715e2cfd6f398c6cb6691b6cb762ddaced1a513dabd356b3bcaeeff187e697d65042a847e0f8387470e0544973890e5bed90e1a7fbb6d80da2afd72f223156dd742d80d4428b90e6675f6162fd4f683e0c2e13cae9b6d6f8b18c1d1488b1589c2ca1ba69df4c14fd99b2907b28576305750e89b56cf60c8f54974b5fd286f4c25c3c0556c1ea2d70a129ae5982b9ffcf33d273e19cb2d207bc5b9f41b7f63d0659c45c45eb8df2bc79448d6785d83ad5308a035bbd5587c47696d26ffdfad12042d2cd2dbba94e21c218f121cbdd591397ec737222755eb2905ff1dd2ab02d257390afcd06ef683917bd7422fbf5317edf74f26b14c7557b1a8f0370acc95f559a15a3af67059de571db783050a3e414f53bf7e5ffce4f55275868d0336b3e3684a23ba1b3433a0616336905b9d5804c8c7c42c545db82ea31fa05069f996e4a4a21a716ed767e2ad7f8eaaff3c87b56229e0bedb87d25f544a3ea8669c47510909d176a7c2a3bbe4ac00a5a0009a54563f150931af9a1060a81c20e273514910ccdd887f9ac5882883e70bddd611a6e45f6c8c63fde8d00e14436e5225e62b120aaacef686d3446dccf5b9b5156d9b1259d3d07f6056942d7e24b337d7f153411b9dc20d2922b3f29efd61f1d3fc4bd6e51b1c3875a6d756989c4e8b52636840d6e2598a5d4d216ee08e6ea9802a42803591f43f39dfd22edad370de102abccbf7b606cf88dea89cfa0396f57bdae6d98fc7a695ee4cdc58f440eaf37c3ba310eb1ba2478da591af238fb71abba219daed0aea449377edbf8d406ea395ca3a9315aa5de74b0dda27d9760d372c7c2036e99adbbdf7238c5acf71d4378665a784b03a52e304e525f74ee1cfff88982af3687d14f08ddf5e0fb391195f7a20735b603bffe50798b56c3c9d4980ed59492663810d1d7b252928814868b35ea3c1d9371f72190d2d8569662dbad65e35f90426d30c0353d8b9654c7233c38f5a901d54fe5430123d5d49601216a05fa0fd80f8ef5a6909a9e33d1bd81d063ff73d19248c87f44a3e33262caa68fc40d89ca7ec8329bc7323d8e56ef381e4b79faeb7a7c9408617d2c34c8f4022f037277654c5334a3a9e51d6cb384a2fe37f1374f4abe8711100af3610966864193ed087e3bf583954f09f10e8ca693ef3cdbac78cab8930c9ccf45f94fe6d7363c17615a6e338cdd04a38d434ea078475ab95fc4567c91f990d1ad448b422b392476ba00ba4f3dbf55603c43f3a28573fe430c4b143f3ef9d25a8c99aaea01fb3e08f555ddad063f9263bf94db2b9d671678b0b069d9dc30dbc8329eb9db499bd5cd2ca59f9762c3ca0f60d28d7d2bd2d44fb0f2e22b79db00a61cc01c15fd338ce33738f04530d20c2f11a61d0e99b36f7b91c2376cfe11f05cffafc4e0fa206c0069e0dcfff1abb58719c0ebebb8157e5fcbeb76a67fd54daab4c8cbafa8b4957766014d2c31f33bf0fae4c8851a782222e3ef6de26c824f4728fa1d7c5a4a36f4b5916914746e329e45cf1bc4c2c1a3631d2f49c12602123a8c73e9d55113d0ebaf2f860f8995d51d8b2553754fdf7eab5ae7e28cb109f633b32e5439a0fb8cd29e5a26c3facbe64d87b7cf2fa35f2133d5785b6bb574a0f8f2cd318a0b7110d328a8b01352999600b266fe7bfacc0b2a62454711a9a19311e4c534333e5d22f5556f293f638f3cec490ee08a588aba6ddd228eba5eea9cf067935bd3b562f4678a23e7e52d0b841caca4bfe05f665ed53262b78c38c55e932b73077de2baf0fcc2b0c2fc76a31d4bcad11aed182c762ac5cbef8321b543872365bc86c5e2236ea911524f37d30ae254fb96d5109d048c2d2fa5cb03471dc6d1145db07a3476054ca63c30f0f1fd842ca34941c14c647e955071d190231a132f9757ace6af7802ea67f337d4f6dc6b20e01098f085cab1c4c92b7c65849dc3e2ea86dc1c985b92a0a0a43964f551ccd15fe878fcbbaa36653f615f5d5f5d1591d4b918551c5e88c2d96b8019a4d009bbf9b3d7f7c497fee0e3d090e4eeda8b4e3505fac5477a595e2fe3dec8be392ececa8080eb557791fda081d17ac5c4ce432f1835da8e5384193c2a5672c652bf0dea91924ace9c3fccd1b4381ba56f76fd769f6dbd6b3aa6df371e87bda97b742719d821b5a7ad35f72a4728e5c89a784e6c35581d8f0a9151cf37ce638360fd6845634b1a0748fb3869e2638210af0997bf557a9267bf7bb25b9b3df18992937f90e22c6d935b9002c8dd861f935f56f8f7f34c3535cbbf4949b40832741cddb2662d3116e0f6c755bf876aaf73736d3a9e0208c1ee46c356be66a39a1709605ddb9ad8cbe5df3ee38689cba922d3ae3cc2e3bb7d322f82abba21fd8dc16192544d3569e8917c2ebf172117909b526f860e4237c57a3786bc5ae128995a7a7c73aadccfa29bdb8c80197a7ef0160201a27510cc955e606df64f03b8842389c3aec74d9a1c2b2d6044d5c0f97e1576e0f70afb8f8e978eae3e7dd9eeb1fde99a5d66d3f9d78829a5057d61a44cd49270d37f42c439100d12dca77845a589eb716d780a31ad6220e1372ced10c53f8adb814d1412eed425e6679f9c71b228a04cab0cb9c8d0bce6e1757f3da36ad9e2e878e76dd3969720a273550585e493fe09490a444655512a8d951d9b1750ad8eb97ea67dfbc43f6fc2f8b9db59e7908c02be5c849303f0afe8a24363cdaa6347f4a000ebc8f7003805e4b5e61aa631931c2d814fb02b9ffbbb86f1f4de6b9b78f704427cd5fe577b732f3873d204bce18e9cdb061069293f658a6027fb5c66bf3b0168621f2452cc417d09a0b61fc9b8eb66419c8e1247ea341c4b062b94be97207b86547399635db7629bcf3ffa37f56bc0cc21b7c3d3a250e26e7adceaee3e2460a21909177c2b4eb4ba0c43eb90e0de69dd79de8e806c197c0b2a2518d2b2a21d3a35d94934c45be0a853a100d4fd48ba8e41da122a3265e6ccc2ece10fbea483359046e3758f9a5dd7c161a3d2796e607fea8a8e8e8c9cdb2326f1a4a4f6ae28ba61f1e0ede1b3a4ebdfe7a3b91560cca27391ce9f139a7c1bcf1b82737be8bb38fb4215bcfe3b7ec3408a909995ec182a3e81a258a690ba5e3d386b1f49be21f7c25f1e180f4240cd43f1e875e993e7d78fd2704ce069e886884ca3a65873c5c669713c7cb54d2747c960bb94f83d6501e5b2a64027c9a4dbceee2bb8dcf8f403c22b936647093e5f6ccb2ac6b460e41d149b8f589ba567138907245d9ed970bea4e6efd887ffb32fc727796d71088ccc78afbf3bd4f08b7e588b69bfd694a2670dbc7eedc9bb0f616ad4c3e900a978d69dd231e32b9300bf6ea07ed02e6cf2b2dfc8d3fcad70b5b3ac2d6b22480bd300208520de61af9e680d96b94990dc256e4448ed281e63698d54814641f6924face8223a05c59b29577c55527f69adfb1db3736bb4f3d2a41bf54cec226e62c3b197fc6b12bb5c68a1853bd74895dcf488fc3cba69b42165f68d34eb2fdd83c977182d03e7b9e15edc7110993d2052d9020b5bc96c93f8fb78ff29ab6e6ac6fd69ba4d4e78117c51c622b082f15f9627abfa8d35c97eb9ca8dc079c7e014bdd0d5a8b001c7bf939bc1254b2dda9400776c2efb54ff2a0fa047c60113738646439ebe5e69a19554cbfbaed22e0e504b4a7a2d5108fbaeb2cebc527d2fe0b66e5c0a661b4c63f2afa715861754c271220389c3d0f0821149956101d9fda2ac4d82e78f6bc03e1a2d5ea05c616149c473b520b1f2ee6c7ca4b455864aa4854035b62a575dc1e148d0ea66321acc4be0580d6564334727cae55f373397f51318173a5cc5fe2e59f8b16728b5607905074fd5e3b48a595b4b2a5350e1e0e5a6c366fcc96195eaf71d82f426be693aae412f10060983434a2d639b0e9f73834e20f1e14b9e77f38b75c4d5c51e602e56f9de4166b1b2ee5564e924a3cf327847b9b379dd816ca0afd5f9d0503b381cb06cf33189f1a04bd5b0e9c4a2c55c3ad8dd0949dc722a8d9fd25fbc21a0f8c611b1261fa1ca1bc6bee21add00f73965ba45ab4eeda9e7a6ee34598199745e344b8ceb15296a0081d61e9bcd976e2a6f570909f194a7d30e3287e8895a26a8d4d505460d9aa6e5121ae23ff6665bd2f995f80fd88a2ea5c1dd4b8bc0903e2c449cbcff98b6a447723fb166856a780ae2ee74a1f74ed09655505b06dae58aa0c895b1f99b8c3f87317944e95897ec27a33c635d7125ff7b4e1e137fd09504b23454d19f9cc3137cc6dff0f33471f35069a52c88f3b6ce8124e5a59a617eb59271caf9ebd46a2679e09986b092b21eadd861773488ab55bf9fdeb87bea009d6b22ab69ec3f13bd79eb2729a662927238acd8af1f89463f10a76023b0fd62cc87405c5ee33c93de9b2ff8dd69f05a1143e26c697cd8f8b45384c67baefbb6e948a8c5a6c232e968fe4ebcf8216246dafb58193ca89d4c1209296ccfb219aaf0692ae3b67419799ab49911386a099e6d6358653958a0aa38a331d8006ec8345a7d0aa30e2fb1bb111adcf9445ae217b900dbd17d9aa8ed4446166111e4d4f10b51aa60415930eea046048db78b01e74491e1395386023bb864c2393a3498ca779e613f6bf3af046b71dd184af2c8eaa3e97bdea7c8b5324bb4606c1c72deb42f0e0cd54ebe0f3dc8daec0177eacec3af6e4297290c993ceb23682a7fbf888ae77a3963fd911be13bc0b6b244c7ddce1be06d26921eb2abf615b577e62b90b495b87fcf32e2c7aac66c8c214210ea02c26287ea60e7d9825add6f6f3fa849ec6e76eca893d767701a396e45693409c71889d53164e148b1b07aff1cd1b39d0698940b3b05ff4e0842756a9ee16b52d25558cf8f813dc1f68840ec25559f8f52511d0a95182dabde09d13b42f6671147200dd7f0e7ecdc4167387471585714753db4b08f05f98e89436a8652d99906534479c997710b39ee67e2923a069b718d821c6de99d28804e69bbe842cb04a0c3da6a084f5ae1c62d2394ca7beaa7b357190cedc850ca09e9fc41e16ea8e50a7b665b452dddc42cad84ef794cb36ea912802a82d981938ed0d7bc1c84a4b2a062254fac03c4c08b59e5c7cb06b9d16896f7912a0dbf3051e19faf5e814001db51e622aef90877b5415aa32b8b2677aa07ed09ad64ac969355704d9baf2039ddbb85420d77b3f46afc57a40940206c78c00ef8f2b470f5d63253824f6c123be3dd78be925c6654a197790792cb8588dfa1f626da349f997185a28627dfe65fbddf81b169618d34e66788f303c71fdc0d7680f0a6949e66d353ac83ef1d2ad578201171bbb51d6fc78336c7d26f862cae7c326d82c7c6eab1b9a768c638ef2b4a7a09850b20feea13cc7e5de6e6a0ba52c7050f103eacb5224d623c161296c84cb9c9576e182c6c804cd0e5e2439b042e26b23bd28ea3397616a714aae07e07e80afda4e847a3b8d90ab338b18f0bab2f5181c8993e745d905f1bd4601391dd2375af881a4189cd0fa32ee3234299e458ab446fce37f8de702c92426c0ffe0f4519c4418a7a3828602ec0d1985ae10d9e54b1b19610cf60da751a04079058f2f0451ff22d6af80f8e2df49ac720accd5f1f18720109def0dd463ef54198dd31213c39656d618fe745fbd3432c331b865912e763fa366d8d7e01feeea1bed384728ae4d9bee465bb91eff99a3b7e03be3e68323bf69423a9e1c1ef7033fb4d3a2dca57a68aa34a42bc899b9fdcd731f71621008b7b503f9ded62f2caa26811b756b0271d003431dcda36cb86ba68a8a0689ccfafe7acd4e10d10ed800c675737598c04f5f4be198b6743ddb1c5bde73b031cc82714aa5ca0de0b39df9f97768ff0ee42ffc6799ba40d1a9463704a7ece6e54bb797082efe7ca90d1fedd4d6517c63313cb453c2e5d5c29d1dc8422f063b564a4f86128cb081f03412e8db3db33c822211644cd835528dd426732803dbce0832c9e738bd62f4f96d411dcbf0c3adcd0a6c6316ced96feb5c75d9e8ddada1bb07c8490d50152a9d1762d61a1275145995e493bfc7625bfa47956533c2623b27e0ace539cdf7105e1694c05fe388d92718a03ab54a0cf1566a8cbbf5190e27c38d41486c51770e0494b19a30a954d46c4a1d5685eba6ee5152275f79c6aaa6717fed428cc7bf788f52ff92d29f14f3605aba18a9456da17bea9235389a600f4483fd6fb4e6423c5ed96bfc33c85c43cde1cfd02d5fdf5e5a221df61020d4df2e1e98bd0e24d9c63962d7dfc0841bee3e9fa848178d0c94b0f0eea59cdf738ab0758661b1ed87e5fbf6480b6e3f2ae67bc64ff2675354cdb9f3b7c390e3ebdb84c659f86fdcc5a59a738e659cc6ecb3139f083c5a7a88e71c73105836bcb09fd38780cd8b9cf8fbccc0c5f313fae2ba7b74c2a1d25f38156fa1e43eb97861c8abefb8c42a9ff22e580f6d3a1be446a4a241e2e6f2b89d6fe5394cc8a59778637f9704e0455780e369f61bcaae7a698f7ea068cb45c8fe8f81719f0a28eb52a8d825f6d36dd934614e84d5a5fe952f0d87717b1cd5dd88d40c83254021bea7ce05cd7d0c17ee96c5d495f9c521b1cb557e656dcb2a6aaff56c02c6b30a7439705c99909b0b8158926c8128fb7957fa6a9a70187cc9f36a04bb102a80722d4990cb4737d5c1bdb8686da1e47bcb7b6c850d6d445298c92dbfc6d388b3ec5a85aaa00c08e3bd9e5960e2c454e043792f33f3f7519396ad8e73ce385fb86a97dae7d45e503e088d4a490e1a76412c1da8b516217f199db262b7972acb49f15df5de643a6863e7fbc99e936b6e3af4cda677d8dede70c2e27d3851ab130727273b2ece4325bacd8f91c361cbb1d34502626df0f58d1f617beb8247da7fbb66135243579f15ceea127c94875a77c3f5a510ae755f09a2662c8508bde9351bb0cdf200dddba390b21851d9f2fa0e1437481249e3df889248c8b8b8680201ebbb7bd2161455b568ff79354ee4bda7db42b415a681683cbdc587fcc8333c2a775c85ce4da52b82976f45686cd6dd7e7bff4ef524a883fe977b8848bbbdd2cb487239270364063aab3781cb3781a12a405deee7fb834812b40636fe0b265f402abd340142f68f7fe67f24be7f002fb1cca773802a1f9724366fe728e422ff718c2c36a4cbbd06b872ec69cc6837155cc25c041b2e7a68812ee860f5387250b08828be1e67a182eaac02e2c50fc3e7e56381078a032fc21d14c55ac9fbb65627056b30af0b57e919aa8fa382ee45497035eb31962ba0de1ea7ebb1d9cc02333f6fed52b1a4c2d48ee4978807064fbe50b4f3cc3006e315c41fd8b135614e0c62ad2a48fcac7305d84205743511230e37be8cd04de06aa5d38ae4556f2a18e09e91b0a20fff290340d754c0ff0285939b48059bbaebee59690165883d32f7fb74f1e6672c7939eb152dcd1417d8b2300f621a3520a3e763c42c40723b77debe51a4386d8578372cad27678bd37771200f71660226261d4df10266c7aceaae0638997007c160c19b066f94d2886a73ce9b140a41b4c683058a74f115b19ee1cde73e427e81ac5fc1e7562a7783705a1cfd57b4cfafb902379680c163b5dce83940715d220c7c6f0d5d6b6a3ca2d38ecca6afb4e3b655","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"11e9c8a61e0ff354be457b061e82c5ea"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
