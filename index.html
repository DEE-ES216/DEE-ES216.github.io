<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected ES216BB Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected ES216BB Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a117ab2485cff75e3bbaeeee6e3328896000553af95e13fdb6ea31b7b3aecc8722618ce59e11c6df76e5fe17509c7f8852d0bb3d6356973a1caf7c5386e3305f772123a5528fee681a73c40e1d21d0368b8226991971683e50ad4645c53c05f91405cde5f70e24920cff1815c1e7435b0f29737a334b578f020a875d476db6ab740e5057b1e2f50239d2d08943f22c30a67b53f6b59019dbcdea4d913c6d331c8f2129851a3d8d5a5670b59bc1018963793346cbea6797829030db4c7804387f736d5077299aab118c60f26f4ee6cf4f4e12904b514d217504ca15445474338a5aba9fe1bd177f3c2ee1029ff6920ec9631786234c21eb69fc3a50322ee21bb6d3b54c73bde56d42c566af6ffddc445903d040b1d7551caa6245ab97451b5e6dc09c1b0f115f8f228b452e5b82eca4195ca6de319b88e035c50cb9dbe1f3b496d83bbea68891b3dd647e0654408c36ff6f219678f5c09b9d5219e1b5144d365a38ea413fef72d99fe0b3ad0f78de81eb6d00332513635d8290292d55669ea237f3d4cd6000e6ee25fc755869bffb036136f1bb9fc9b822721e70d16b46ae6479eec93a877e06a6b19a790ef0b00ebbac6b5f7dce98c819f14157261efdc77e2849de721abf438b4f6be2e619d8907284532684c0bc13c6021eae4bbeea88f132502e46420ea13000f56809d42e19cf0af13654be98f128dcd02adaf89930b9f6c0783f485b7c836edcbdc311714abaf101ba84e8b61ac18a5fb85622cdfc3d8746b42b9a23fa6d6c60bf5ee7e6efb093bc3a6fff6f5359aaba84b2f48a846d262f3e51f7e41f2ca6ad0ad60585f956f24d36795eda9529bc5c7f9f02199338c16f8854a35be77544967d599d79ce9ac9413bb60deeb6783b70689600d20f096b3a68291333ba79c8c8ac0e2c000c7f6076ff91f8433290244ca21104850921595b7dc28ac479025e13e0850dac6c2e3e1e4c1080207d9845b3600346de372f84e91de687c818a8d3f0ebfc37f860a79d8a0df39f7eb594fc7e721203c1bfe3c02554ee2133f624c3361296102d99efe7ddd611a6b44fb8fc497ae84802c5e8239c3cf0b03248b01d620d98510edc244c6b89eb930a7bb109520d03e8f9ce1f3afb38b50f25c5e8000daf1059811a4bf63fc28a0ae398ee3ed053e8feeff975e118239811d16300a9fc5f8fefc5b13966e87e0ba17635b428eb9588ba9e5b2ad6f42b108be75c64c5f9d8512b35e9881b7843f52908e2f54042155419d2015a4ca04299125e87997080012595a8de116492b152a35a50ca8a61fac90e31f65ecc23007373d430f65ec095d5c3f4783a53c4b7401ddae6c84beeeb769ccd8cb8ca931169479a3dbad947e4f111b3c1e28f24eb397929b2e68723dd8bf1dad33b1d04a801dc34d58c99875bd117d254c874603d05eec8faf90b4c78aeca8ab716a49367f147f7019aa596ef5a6c9cf8307407cfa446e19e5a2a899cd9f975d4f48ef634e1417a6b4aaeaae510e8d10fea17ca0d75a760aed43a944b2d2affa9f72dd53be0901635ef6b7da5d2ed0a93560c18ac33076fd544278ffca813fed9aede5f9de4478c0c0a2db270a3f0e371d61127bf933ced238120e330545917d08dcb91c27d8cf946035960a40bd3f4485ca2318fb4bca7546f8cb10e386406e20bf13897cc0ace49b33f4e2d240d57e53418e6eeff312a41e28f6309bfd970f9294d3a144a95f1f1bb98795280645d7499bc88ddd621244374549bb88fc85b1da19e205597a26788eaf649df15a8cec02c2cd4b1210767bf9ea81257edc6d5dc12f9070e4ff17f31cbd416af88c829bd4e911a6b92bb0f2a1ed06ae80c99f7ee3a0f179bc00d741613b0d554093c956754ba7244fc156c995f579e8719cc96db97ed1b601808d6a7eaee24deab67503b5e41e723d519aa2c042e1f06569aa9d25dcd2c59b1765f2a8ca24d24580b99424e947f0e727299aea47cd2ab388d0a7530529fa29ae9f365459e563929550baf61ef64aac917c4ab8b703b9a6d4390160e39532a37048d0710293945f0f3a9f914e6b38b947fd8a49081179a420bdbb4ce0100cb5e8bd58eaadd44c0238d9e42e3bf5f7d1585dc34a9e526f5c13c9951c5d664daa0463226249550339dfd1a69ed5961bdd51c6a2d57c990ca84211d17a9423211bf3bd6ff55c4e076eff44c315c55d0ef00bfe302d5f6eb62944d12e5bb198065670f13650be2f73fd70dddf611906523bc07b7dead9e6a35fa20b854ca5ed387bdf20cb7b22ded6c7249e7bd74413bbdc1c0f0150405e46076ea264f63b5e6b30b28817ff8dd8f9315487f2c26979277975bc1b753765a76206596bc9049a87e2b9b02f7eb97da305fc7161a9dd563cf9ef6d1c30b0a914f37f1c4abeca24179965b407754a1498d1d75d00f6a92895444bb7bc87ebcebe63a65f49749f7920e8a87f82d856b240f38782d63a4f243dc8deaa8343424201970bd7246b466ef8f59d7d3d9e28756e2ac9431be8595e75bb281b351e4c2cf7f69985738cffc6fc291883d5f48a6463e36beb2d3cae6c111b77ea65f9e6ba6ea354ef30878484539032d877d053477d448c7092bc278518fd43f1034766ea2c22b98de81013121149d45e0a590727e7322a6a56a4105be6d8289ed9c88ecc626f9427fda67f3d417b2ec9d025a5b953c7ef0c8f6482d0cd0fee8c0f67688f0ac4b0b7b92a5a6456271744658d793207bc46f884d9ed2557a8175ba13af732493a60c3e3866b4548822c6aabd25682b6b6113ad96ffa193f46177066683ef630660d74b408d116766588054e06b0a0c5fa39cd27864466cbe1f0aa865a5ff119c5bf4d85ddc838c6207f50427f93daab14850111255a8b1c107f2e4c18131b566f625706c91dea94bfbeb33cc28f9a2dd7e0b213cabab0774c17bd49388fd729c42f3a29e78fe123087bf144ff5a780f5bd9a81eb8c5b49d3864e3ce948a1180b8fb5fc2b1c77741cafea003107b58da62b8fa6fa345b234d1d45a5c03fc66f84f2a959c27727d3db6096ff61ab3a2585ceb3645392c41c5e30eaceae847e78851b5afd61b1790736fc58b86f47eeef54fb765788f33063df5757330e5b847fc960eadfb4ef99bb3128c758d104bcb432243ecdfec057e3f35975eb64e33a1c711ca1e5c3c0261285fbcb12e23fbf393e17a3efad7d07f3489326302ce977876a5666b75d7e1cb1f3c38903076be680a28f2a470dd6a13dae809b9017c78fe6fcc22337604f5523bad7d343fa8a016fb0f481f540cdd3500c79233e0bee627e580bc1f06264b9b411adba0d68bb09e193ca398af114b483eecb11adb7dbad00f23ba854603894181c9efd252fd716f27e35ad9ba8542d5a52a90de663e14ce6f6a7c49f7ae930c32a943a58bef4ac010d2ad38949d3719659b8d1d30c025afd237d133dd84441225ecfd1544ab778729f10dce29c261c3f848bbfe2456e5827f3e47f826daa19fe73742f5a0bcb184c2d4a51dafd875cb33d0e54794a54dd162a5e4e7353aa6567fa73a1716e791dd77ad479a6ca20210d2c93e1b483f56638ac8b0b92f5a7758de31c7a4c7274bec8ad07c7b808361f577a79ec17ceff37ff0934ff7408287b8b49eb2a83ffc6ee70daca79dccb5982bf13857b2d606791c5905d22c7a81799328e5ee768684e8fe133d03803429e74d6d28fbfc92046cb4baa8713cec97f89cbf072a7e07045dc9d23a758909684cf8429d6b2be6a3c2d85be9d67959cbfc3bcd22a5730b97c3dfc83d375ff5572924f6538b3fa8acc05883056fab9f2c6293176c8bbe8d1505e2e5b63f69b5db8fb8cb40c4d7a8b194cb1078dbde42c8a7ea7eaabf6f176acf2b99d715dba18802e45a4de796f2b4d29f2228ec006e3e0984902ef45270853eae23e854c9b2e4397b7b172b924e7ec50fc3635ddb6738f38f90bc5c8e5aa34ed6ce150b23b192ed319dc685fb2b3fa9a03d6765c41d47edcc29afc98f8f50fefe31d573a754e11664b441fae037a0eac00fa0d8565b05c59eac11528e5df5c197ef1db1d21d3532fa1afecaf3d387b8b761576e51fde54c9e1b2471b0b484ea7fdba34ee58e6a37e39145c94ac53a15149810b56ed71687d8d702976e0973107c4fc38c2566134992c7ce062635b7d7108c8a9ba9df424690dd2a3e9f04a0da5e3767aa7fc3c7b2d57eb72320c4172e592375c6ef4c1ae0586003a24306b82dbcb564daab1db25e480b5c8edae6178bb146300c97207d466aebf79e8b6dae1954de17ab7a0467ae7fa5fd76cea0071d53d43f2284be8082dea9bb1deba39aab086c8b491f8f81a6291e612f439c1a62cc6ea5924f80acef7aaf85109c52373b62c982ca07efa5be074d034c239123552e46d6cc9226e07d22ca0a01dfacde932135003c3c78f301feb6a8a41c9024550e633c3b8ebc313c98b4c835dea0b860f40fe20cd5fc124d7d03f21454488447a2e2fef6d24ee4c52e154bc7488b7d2a9940a764f349f1226075ad3e7b614896e2d779dafffd22c74b307491db366cff376fb9c8699fe67f19e07bafdf0c1576284cce102640bd7f86aa7f1a761e92e2ed2b12c1fcb207c00a38a0ad3a95f10d770c1b3240a53a8e78879816e56f1f3e4844a16fe9cc84b251c75773c3b9bfd8f24a667d3d2e43e25ec466d5235ffffcf47480ae6a01a6804fef737a6e324f539ef401e3fb2a705063824b5b284c1210df3847cb4f8f1ac6c6c74a86bd5ffcdbcf25863555587ba746330e190f2b0ee723ea4925838b854b28bed8753a212a73e7294bb86b60df596399e73ed83daa635270f62ba5f3505afb60d07888a090eaad8260e8685f7bc7113339c8340edf5091645580180a316224a440e137db6a203ff0af6247875b310aac641c16a1a53753b9cdb088a87ab9997815acd126d0e56c036aea1b0e9e4c3c0caf68743502135be01b88a2e6f580fa977ad204ad21fd5bc560ff4f3345cf1aa6fb11c5e5602e1307b2a41ef512b95481aa411811e522684c02afb8cc202f1a91d1f82619c0d43a7ba26f47113d7816b4182f681ff6a01b1728308730fa14e2518514cd3c556a4993a46fa94cb23c7653247e03f52035908cb854d8c5976f46acafc520a5d99c961dec7630ec658e890335395cb49fc64cfdc3b7f0569bfa415d4d8e705cce783737ec46fac6f3613e0aeeee52acaa65d4aa5faad8d593b86b91f208815333a34b5ad50b4663e1e46da607fe1198aefa9402ed12d04892c8457b2bd28e8f75d8d4c02705c1f4be25951d8205febfd4b5d5162cc3a335b002f58092e2100c63ac280f8a51a7ea510ed99d61a0a04acc1b3d57ddea87063275ad5c8c77f8ad73c22cbd1c2f2da444519b90f18926506b9661f40a9b508ae01cbaed63abe3fab0ef6df02f81623f9cb8897302f9e8062608c779931d469ae373d27a2bcf8c9e976a325086f01400817ced38d5ab152528fc8c99272d6d2f4ea1d4068777fbbded4a99dfdf2eb66b6e240a7d303cf7dda584edad121d3a5778f1aa468bd927422ea7ce8143c1cd8490d8002f05219d0d2c43ca8ee1e86aad96aea36996943e0a7ccd58430f12520882b85350da810bd23f2b710d106b8d59e82c8c6c359e969e77a78ad145291b4293af9d55e49b519773f0ab6a0d9ad36b604cdd26a722d701a427eb45922e426a154b7e89fb6295d0d19a8aefc73a2d9e5838f8ad58782a2663cea1907292e4ddc95468b93e329240ac4a59fd3412d558b118e6508dd73e11252f07bbf674acf04d9c785a08b3a4e04d879584bbd3a79a86af454c6eca058455c5fdbaebb362f047475040d2b1cb739139a44f7462188bcd76320565d63df6d37dcbc442b9e07fadee0959d102663be79c70187c2c780c0f627a98ff24044c615e7ad83b4a5bdec566482f550189f9ef72d83946726b81cbda565f1c1dcd0801ab35d6e0c20a1cf51643ab3812bd41ebf17c6fc7d2a046e771e3c0c80a6d369c44ce6cdbda50e8254a931e47226ea9f432b32d5bd18c2b489a40c2cc0c37e76a62581f6e2c33674c2f275ce48d0cf3341315bc4d0ca9ad125a6e09aaf59cc17dd2b9363ad3e99497635eef2d0898a9b8fc3c70ad2cc43646d4462bb4968ed597cae44a8d26cca21b3de8c5d4824d5f689467c436d072f95752bad8246c538a6520c01810c4dd59c5e007c553d2283e3a5c3caa944cf89703c58d5d46780e1a44573aa078522ac76f6db456fa27140592aae2f7300803903a7c8793dc9e45934d376e40021ba30ae0941a23c359d0e46f7ab761116bb1d238f8dcf957a31438cabf04349a9d04ab438d3318a54c70493f1103f4112a9d868e5dba0fc61a3e454476cddde047030fd85916c03cdd60757a790c8a0e5b7a06e6f01161eb86c3badf2f0c6324815523640604279ff4a8e2aa94fab285ec4768526a74a76fdecf280bd8c1cd4a1b0989980cbb1409a4d15f301c3f43d25524b5d888fc879b29ba83cc44092e1dc49d6985c20c1bf5a0314d26b4d6807cd8a953f8fa7466726d7091d7c77fed7addc9daeb625d74a1461e5369a042376eddaeec7284923b2383b64bd15c86dd69b802f5eb88711c68191b891f026321c34f4405bcffdb83fc746ccd7de0264817ae2cf8a7da6cdaadf3d9ece920b5c73b586a2db1318cfe6acce66652971672c78f2cf4ba1493cf27cb770d3cd90c94cecf0f339f49ce5e0b795d67d414b789a42028944e5d3c3f321656e507b88948b88ce4a89bac830f320aba4c8d1ea5c3540da556a70bd596c165a7bf44b0ce79ed074c729aadd1b8d9d5791817928e8711fe276f6789e11983ae5af7bd2dfca7e476cc2e600b57337b1b6ca7ae131521fc3d0825dcaed25b9cc78a6519b8834cf3105af7fe014f4b9a706089de7c8c74093cbd494222e82cf6c838531d092c2527e43cd5b8c2919684a67c8f4a3b46eebbc3c818aab8f102826eb7dc44d8419ab38a764af9816d4d83bd257bf132bf70a282f373ff881f51feef986ba9cf119ae33ebd388a0f567b331e1b40e90a5b8bf72a71075f9560802fc2eddf5efcc7fdce078f7ff9c8b5cb93558927ac0a87fb1303f4633ab888956e3f3bd422f9529c6598ac3d5f37c9db8d465aca083095d926667f3a066ff776ccdf938c8a01b3774131d136786b9c7a5d161f374b47a1e5b279344041537a10a2e213f3710df385b79b60ab30637cd5355940b726198c14b1f6ca66dd00ce4cd79cd9221bb8e6fe98c3c1839902caa2751a812c5f3c7c49a2827c82fb2b2afedc7e150af47638079ecc2dbec666b33f2fd110063f1e95598f922a7cca37a88edbf31e95154ddda29b4c16c644fde983c29ae4541c1a980e1fbe2b536bed0b255cb6087a03bf0a99aafe3d31d6479848764a236dca4abf1eb0423933f835af777516b6db290b6f71fdf0ce289b45ede4b991bda01fb014c37078506edd3cde0d66d52f8a5f2b0a29342eee7060f5e04cc8748fc0f092a6e759a7a1ff8da86f5702fb1e6344e3b40f16148bb85fed20a52e1a4b7770173e8230efed5d14c557910f934c7d2b06ca4fab0c0b02faba070bcf61c370d92f36dc353b3dbc1e8ae4b85b1259dac7a93af656161d8da5a7dd60978de22385ae19b76073635332690969e78082026fd4962a085fe8e838dc594c5b2c45eaec6fb0d80380c56c8e59da9960e99a9a458168b9deb99811f7c425c04f7fd69db6536f56639233e53596f637febb62e04a0d8c321107d309e39aa63783afd5c6351561813eea87884d73cfacc4aa4a8eebed35cbca40ea0c9239381439a6ef33edd9855eaa48b931348283cf1241d472b88419a614c0b7a5bfb2029439792f8140fbf88d5961ce66ce9259a14f14186e6928321fffdade6031db752cd0dc0eb6b1eb72e02fb97b5819bca752730919df7df1602be550a2093529d4a88927021544812d73c6bdcc4e9d58ce861e0a2c2b186530c013e4ae0cc8065040df62c37300a75eced5d919b41a4636505bf01eec515f54fa07d7b6b2fc52de3009f83224060c415d278dd19a47ddfa855ae617b36dd1ab697b67d752ffb94526d01583c9c18df464bc1de28a4702e9ac21e41c3571c93012c1dc5b2010ec0035f0762091d690b650099bec8b6690d6888c642dabc89a9a82b55ff13de0460bf2913c79c3819f0c42b28aea25e008eb033c5af6bcd2e7adba82cd6e89b1101cafcd53c2c21add8151cf1c201a46939e52b8c65b61fb9b9fd943480e3e2ee54c0c29d89829584e1f9265883b7644711b4b9ad576259596f8de757e9058554d9f990fef745f7a9e56f07d2c8e536785c93aa89a7d3a411209dec83ed10a2135e2023632e7f57801ba98276a63b4ae5b127dc173e7cef049721dc50eb14a12634b1011379a733e0bf0c8056242feda924e38d099c49c9bb13b676a79973029d4b236b50f74db890f64b25af61ea59fecb558e072b8cdd32cae28b968b0746ec2bd7b2b910ffd33e5833db383a097f4735fc3739b7a62d1d0f8d5937b4ee50c9fb1c72b505a175db7b2df15c6ad1883fa3bf918ac01f842d97e97c2903ed10d244d7078ff540b501b672429be512f85543421bac5c6933a33f113a8224788ce9753f433b853474f72c8f3dfe5fcd6479cf17494c14010bac2630998e04f73c03c23a85a23594110ee063474344d0f1ee59057945a8cfa05dffc5c204bdee5b2ebc5efda4f6e6bb14de192648c43f82becf3a8ec32a0fe9ec0d471066091afa0342bccef42e172968ff7819f0ba610aa53e7382a339d1b6c08bc6706fc08674c938d8d3c1136f13f409b8c032ff613c117da770b53122b044f671e0a93950455ff20a0a49ce3beb557feb80050fb21bff9ef89b174b83cd4426d9d9b138b331a63fa2b989dab81b8ec148523a9042c4c9ade75ee309d70b038482c09c27407eb2be5805ad3de689f6f8fc53fa3ea4a3a4a97cab31a8a1053e6f1d3d7845c583750f84b62d0bc4a43d0c32a5f14f67bd2a5fca1aa966f86a966a8b1cd0d9545eb4050af9178606db83239ab3d1117dc311299efdb1453f90ee329cafde8d27847316990fc29411a99526330436ac86f416ff4adfffd5993881166445d3cc5ecf844f069cc238966993e7c559e87e5c1e3ef4d54591b8a0c7ff7c1c2b732af8b1847f36445f8244723bdbd7af8204351c912b5e1bd9ba62263893061db7bd6e4da9889f8f96a4dfd1e5c6c9bb6fc6fea30a9337cbaed8358564b4748049cb1ec28696bad6ee2af0d5d7ad3cced61fde7e0f95a99ee83fc25366470f39ffde3a2bdc47ff4615ec5f0df9ee5febb66541c250b1fb7cef573022ecd90d21c48eb047a46cb839e887bf540ec903a1c5752a0915eb708fd94655a1818f2a10b682e1f28aa483d094077d4801551e13e360db15bc194ebe5227dab9adda116c124bedce04f937b8b87f11d5c4122aca50a09548e3470083b2b2e1ea76bcfec74c1acee72981dc0fa00310355a5ced96bfcc5c4974974b59a6d17ed37607fe658fcdc18978ddad057760195614317b48b9149dd2fd99c2f8be01eac0667ae73dbabbd289e67d820aa08f56ccf19ec20edb1d8d48146bb6ea01d7798c0a0aa5df1f691f96748c4ea29eb6ce34f3319df80ccef34a51cb386d667af35d190ff3d12db44f340e7ddf2cb462f6667291d072c27040cacee9d6d48fb881703d9aaca2602de61e8bc1e7d26648f350c169f3e1c062b705657b0cbfabfea5ee33b660be3b99771ab3a73d710ba0e617a333855b9aede08bebbbf3cea31fd0d0e9f098e80c848d5f2cd145dcf8a8998115436afd1f032ef56a74a4bbe33f64c7a8a12745a3fe24a541e6ca04906c6951aba704fc04b7f251262110fafc4eba620eb539b0e675994733666c1c3c0d120ca986a7c85b812f171cde8759db0e53bf31c7a1a49b64997047c0282d480fbedd1555d9ed1961e61e50f6b4197a5908b1f2dc9a3afaa06f560635ed3b5dadc1bec32958bfe78a9158baf9b5f2cdd874151804a73fd2a93c3c895ca221f0fd6bfcd02beaaca057af0de0ca26475d2847ca83dbd9819e440cb16c8d3ce4db79161bd3b09a168be426fe15ee82be9215c33f280e5d0a08b70e5c760ecc8c3c045531d19d0d87aeeccbfeb1ba036c4f1f7d7421154e849ae817338d470beddb82398f5409c91371d4a385e35e6bbbc7236b6b90e028ca669047d3c8c5291da0254351aed4e1c06fda1e9cb2c4726fc861f11279bb9e4babbe517d1b72a810ee8156efee4ec768d7ca4d9d394ae8799dd0fa92d5e80ec1912a583693bd1d9af7cab66677779cb00eaf62a2c493f904d76e619965f12006772663e94359106c63114fb76cdcdf181f8e15a7b5e00e71966f18b154c7dd3b3e068c205cc212d4a6231b18a4f981acd86b64a54dee45520a664767fb0bc24f182d38e16429fe8af58625dbaba538750677041d82a17658ae5bbbe67c118a8ddbbb7369ec1ca7945e850ef3f512d1bb8413c3ad1a2c0a601a933b636effa5a72db3b48667b4ed47e8914b5625d43da8b2accbfe5bb82ef03d18a3f62b9b8b74fb8b6cfe226d","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"62bd9f04b8b8252be279b9fc1f4bd2fe"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
