<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Evaluation Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Evaluation Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b3c0f47a148ff32993b1687ba7a4d6ba9900417328340914fd4ffe9e601e7ec11672d5f9dcb775bf645a5c6604268992f1a837b96d04b10e2f4652a8b77323ace3baa1a357ce44b3a67c4b8f34f09426c3734c5f45a0121204a1e373a3f15b60efea45026b41542046d074a378fa39dc00721474b17daae2bd963d81f9fff85c4a918491abb43cf32e7d7fd8b93c49f2ed39b51182053a526573d76d7dafc54a21a51ffc493d5d1a571d73df254bc5e48914e6d4b2fe87a86c2db271fa2e33a8917434b78f551264eb49adf4a3991bff8cfb9bfac5501bf652fd0d81ba63ac310a6a3f39fc67632e7fa2d924359484ffbcf46a98fa0c748a442ef3ba9986d22126d3cdad796ae7db3eff35e494dd4e226a276bbd5e6b757cc476a7dbf78d7f340ab2a986e5ec058989d23067b1849934dffe9d780575525fe8e70ac8f0fc44a29bc760e5e3261713ff5f422b956a11c14ece574c47187299a745e5c08ca9b31a62a10deb0153acc853906a9211a4373dfe18812b5051f44dfba72672e6b15e6fe7da402f760282546824a2dbdbef25d5de129a99e20974220f55e81a850b2f8e1269e455d408c4f9e44c21fa635407ba752d53bc4a5efc87058803279886d99b9edd7b961229f8d1eebfafb69ae44d31e3586fc318970e4224515b3981c133cf40b3277e11dfaef0b3168b9c3cd1676f187f6d3797a5b37fdfcbd32e3871a1b4ab3897634024ab53f9944c51a12b4f711cd6fc4a806c48b6812b82d71e5d01689a064d5ec1fd7fc98860a5cc5adb04f02bd547a4613cb74eeaf6ec89595767e161d781ae3d5f842e0c51a830041166e3332023c1361a284a5676a746af48004602cde8572a46ff5f4a57834a4da6dbe33932e75614a1acc126678899a8212aedac50d5d5c3e2132ab34d27bcdeeda5dd229d610d882c6bd1357a70340c2d863ffe6a9cc9e6c291a37bc807462afc73928b51c8eaf6e9b2d98f9b2c27134bc0f01562186095689f4548e65be209194899a8a4796654b1c0982858a14df91ab28bd23309a6ba20f991574a3c6c15334f9d75c3636874591ec4c6bf0f05df9287dc898d529555029c37d7430ee7739c962a6506066359a509473c25aa96aecdcd5516bac945c17c1461997a1b78e54604d0d9498533b7d65cd6e9ea76f6c057217736b0603ef179283ea9abd7c729b265252b205bf0a22a4506c1c7575ab8272c24f178b5ca6a018508225a897f6f9c5f1f34b056a2a1bf8097303be79fa1c3b9562a970a9794219cf4527db862be5d8a2077724ccf751007101e1323dc70f714134effcd79025924b8f9623a09869eec1b79d9712a1061bd2beb931ec86b6cf5db19ff18a469c9af81cf3782ec7f35d6e45496fa42d3e13c4b7fe6c820b12bf8b3d8e2349541e8c226efbd3a63271c7bb50e70507567eadfb452b58c343ead370120d846d3ca563c1b9976a9b6f92f0898a34711e09a7a582a69ffc1e2360fd53b7d5e115470dda7eb062f3d04987b1c3152ad77b90d046805750c8b60fdd8835eadf1484c7a2a606b442341582fcb171a4cd8d36e39b2ea161bfae3b02ce5de617adf4b9b0b36955c9eecf1cd139f8ba13c318ac25933b9aa0102f4a470aecafb5528871f7005d32e38100ed40f8c4117b5348618a1e18086aa209db7837cb6612848af8c93ff656f7bff523265bbf7696d1aec8ed08998ef4f177d911890fa6f79540ad86a4e32bae75354be548cd9e811e3975a17aa5058cacbe7eb20c4e0a1876039347ae2edd3cb72f55ed1cb92590e83c8f163a77881ad1a4a06f90b3d6e372f0214bdc96cd346c96601517d41641f52d4aa0ab24394af1294de88167fa293d90edf7111990f3d9aa5233a5cbf220be0be3e6d0515075af261147c98abd9c2227463f39ce2bbb75b428a50da8445c53b7a55d9cb671c01a6d60224481f71ef2bdfae557290031899d7436042058653013b5d71ecbe4d7b1a35c76bf3fd394d422fb6969579dd573772a73c0eaca356192e527f95047d5fd09685f4294316f981909f1859472bd20907c12b3b87ba4f56d889cf80d763532c57dd1bad34d00c895271a54c78ffe4fd84ea769f93a0e8d6c2e584d34426398341c9914036c996368b38b5f3f2811d047aa95c60d98bf081dad157b778e9c8c26af5d25b0e65b6e627335a85161b9fe616668d01380758540e98e67bb376b3352612e7d0cc8a7587a2731cf83039c4c66fcf266e5ddc7545a0db92e9e840e325536c8579cec6d9ab458798cd4d41e5b2da0466692e96bbcc5cefd215707d9cf5bfc53b7e0f4c125bca67fa435851c34726a150d7d8da2f2a6bc68a12514b837fbb243bcd72cabd3164b25ad50b5a1cba3fee6e54eeed5ce99bd48507399b7b502f7ce13096321042d5c9692772cb4fe3c7e54e3da2086f033e96b29f6e59e5eb33d806081841f37fac92bd732bfd04952998b8dfd4174f8139f1c20df5cd09c3649118a8e46d53dbd2022187081e2ebd0a0fa6cf71519bf42802f887f10b72b87e3b7f965392c7834d9c87536b4e87c4f895121ba415ba535e4fcd4fcb99d6317fb4b7919d2198f9e15dc26d91a63d4314d0c3989981b37bfb983c8f8f687c8863e53ba191f6495271cc84b647fc7a94a77f0663cc0addbd291dc68d8d00dfbf19f5df7970b77fa429eb5e350aeb2269a0a09c6841c6aa8b9f5580cb1c6e9112534d604a13f6278de10151dd34174bee6ca9586e1c06396b61f440fdd7f1cf2bb4fdd5132fe39277cea65f7c0822c73dace41bf379fc5d3dd37c55463dc60be1696a7ac3b04629ea779abc8e7b404cf466ab66ef8aab5b62d2b7f18a39a29203e90eba35564a4de1fd37da45197c44631322c5769a5a2da136099858c4d92102fca6fbd0ee16f2fd1e90df12e86809bcbb169fe2307c3875c47d0e8b41c25bf2864d9565b9eb4111b101a44fdca78a4f54f697aa5ec0c38e44d3941eb3c0ed6fc3187aa8535320c5706215d4a4f2249e26574292463b272fb86e05a806778ac347fc4c7a9dbecd7ac36721cde72dd6615bbc466884113f32ecd43b068a54735978f99924479e7ac656942ce9b57d67a3a6cf2329ad3c9c1b474e6455f5d7cd8551e884d0b1be9c56ab92a35d599c655ca6add8fa9323528fa160dc25ecedf5655fcf7aacebb11e5e8b2ba5b5c7b29893dc274ee8b445ddec3f69c6fcb42f6ec15259cc14208a480d0a87293ada37e75dae04454d051b7a30a46fc479c6f1dcd3abfdf7aba9131644231fd772c4afba8a755122ecdbbf811ae2807bead4d7c2da8d1d0c0e693bbe199edc3a60f1f090ad767d54400fe047472eb88486399a5c79f0f05f6b61640d7cd5f449ccfe5a45a2ab1da1e0c1123e64882753d055e03419f1f269a4e8c4f4d9b43868fa43f7d6858f76b64e0df87b2045ddd912b33cad6e0b12fe8b94967165db5728aa032cb8da78b3ebf0a7b247c6fac4c1cf7c9306c4292d7f14d1246bae1df924fd77e5f4573450daaba61bb14c21be67661bea7897c2bdd6957d6edf716dadb5dd5be7de551db3ce16c3625cbd62358bbe4c0771de6cb96ab7ccac1ac732682230b3278219134377d68cb17025297b0e72c9902a3ed85a35f2e563a8d45f54dac32f2715a5b2e4c52df70cf8a163fcbb14e68cd82a5510c1ebb5609ab522854cb62c317d5206128df7e8dd06645710d3a5da76bbdc27bfd9e43347e585512be45cd1dada29b6c2c8b12799f5b7184f138472b98737b4f979b9cd50538ee4d3d0652a9caa677652a0b0718be28a0b2540a8144cdbee837c923e340cb6e80f4cc4adef8502e5bbad76569ac3abd1c8cd953e4a99cd6cd18b717f99f2cf021959127ba14569ad6b3d85ca9f3af77e97d821a47e84c60e4217ab27abb55c0d298da8e61f8ef6244da9738a2b9655d660e98f59ca2a218fe37197c40a50ee221a9062a8396abb728476b2183cab0fa8f1b20fdab58ddfab55dd7adad3a99cda46a191f99e10c804cc508f936adf6297e7f553635d1c079b3c4c6cb78d20c3ff45f127c1fcef63a908ffe65ea4cda4555b197c4ed3be24418534bae7f8f6022c7c764fc0ea6efa385b799454ddf2bc777a03c8baa5400ce3283f7a8deae207bcb3f8791e8da79550ef2314a5747d0180647dfc733c6013d14ff5bfe83314be70d4aab0a8cb56ff5c4800f468dfee3426bbecacc4f73025358a8a01a06aab1ed8f0cd8dae67a6445998eaf6b21f9dcfa1120bca053b8cc2cfd8d152e80fd8081a08c8939e459573a9c39c4a79170f798044ce354210004defefba481520526e0ed0262a19b438f2949fb237f9db42f8c6a6d4e7d3cd32f4a37c39efe1a5daf03f4f090e9664f474efe8189e351d4e0c390dcadc534f5d25b14913a37fcf7b716abdda83d14a92e02d41ee4e0fff93bcd5f1bcb9ea43ffeb3e75d2c7a022ae50d2ab6b03c214ae3369cc5f175b31f7b565930168c1325e2c48225d0059c1150be8a7c17dc80eddf268445a97a3509f6ff08deb84e3ad495cc91f37097d2dbe0d598e23e48d8d0910356e16a9ea9ee155d2f4e0bd70011d61fff0cbc85372c5e8453636f4ceac4e914130156e4d65e36a3e07258747c01d4a70be0232757c64bbf8fc0ed24b01d1ab315675b23a3c546a482339a89213bf928bddc312852ec48c7c0a1cb051648eeb506b35848f8d5c70810e97fdcee155bde29e4bf4682c97362b4dd0bdb8ca4437c79b09e6aaf7645ea92a55bd25844b0db2a8eb95460fa7439b0dede29d22a09fe66bc977d979422d4fbcac8f09fef53d37d705dc46791f0910abe19c0054c5d82c6f6d764f152cbea13a9526f6b757a6e91c39f55bd16d0c7c6164618314d742d6b00cdf205d824cae36d8ce35e6c75e3d007163f7e569a9f5728a3b49e8081c31fb39c4ee479d6735b577fd787a1f9bb06fb0c8d1a5fe8c6f30fee72886ff2b995efc8819b7ed3e03aa9c2f43ff8eb3f45261575561503357306b5305b14381e4f8010e3a9c81241e2d0ffafc2b0066a53f88bf9cb2a9269456852d8eb3969700e6b3f0667293023f67fe687671f8bcae46d7634578ab65ace3d51b98114d306922913387f6a247fd08b6f88489c0ada2d45dc9e3e601c92e5cc4f4452e0cc1a3293fe8c2f6a16a5b95c97d0f7572940b9d191b9cbed92360847f3266d722c10ea1265dd84b83e74f09835acd073f91a029ec7091104ce22ca00eb6daa4d884e19d0fb42ff2b5e753b9ca5e1f574f5a954c027cb1659cf31ecc7d4d89d840c637ecc13ac1e455c7832e625dea59b85687d405df987ecb9c953d3daa95aed701bba8f4df453c2c48676336fa2421caa9a54718840013cfd6bc8f6687b18d593bd31b54cbd3c2167da66a166788a917c33264448ffde187df71f3e44f835bae058bc4b74e0780c2d798cccb8d4f9c195a380c79fc07433df768b0051f9c6bde18e7822ce856dd2ce0ddbefd0de699f1fa1147a2b066b65be7a31d707253cf56e3622a0187797e4342fe6952119d26c96c28c8d643bbe5ac8ceb3ac7147fae11393e4820a931d0a4446d7a15ab1befd455158de0535e9564a3d39c914c705d4f9c5bc2413c101caf431f96641b4f4ae993d94123625329a5b36974a5dd8bcfaf535b36502ac5b338be85d27a5dc5fbc8217f6ca0a913b71c94f0ad7ee6b11bfad4521f36a7f479c7763b7850ca3c37702d224190103e0341a8620615ffcbcf6e05b8c07c409f816eec05d4b028dd607b716c1594576f9d2fab6c29c604e12f9c711dda66be76b56a975f56e372be02f256063c1e9cc56f3aab46448836777905611350a00f2f0800a0374ba8bfcee4f2ea7e06386852e13de1c43392fade659e961b4c7e29fa5258bdf3af07d591ed1e4a0f1e03f1b550da198458db75dcfd423e5cac036a0be129c1d5c44862c054942424689c5178bfcc854a104083823f9616cdf49201976163c48ed17fdb70e536aef3ce07cd70feaf9043de2b6479c387aa7dac66e8d78281b932b97eee398f9f1faa2ad18d8f78617b6fcfc1caa5c872be2906f33cd98c30846e36dbdbc377545d5066a24b5b4b2514e1564e238e9b39cf05bb01f83c8a202ca6a1a28cbdea6a257fc5187867fe4f1e4619b989af33a067ba5e65657c50bc908bbccde72bf57d9e15d9aca2820ca5ffd5be0935fb449a51f91f198431fbbc4389a00bc2db20651873298f031012409baece39c8c078e76c259527d1ab422f52137e00a63b3cb00db0d9c05963fe6c2d56b05df5d49f957f0bf18b9675f9c096690da5639719f8dc6ed0b2b75197fd7c48e478cd0c84499954cd18c85b10e8935454312d8e4ce77c22d3959c4bdd06c6ce6a97b57fcdf2020502c3cb21114811118680f3452aa7868eb19d4531a6d3ba6a7c00772d088b96de4d59671b68bd88d76b24e10ddb9b0e078bfb9a9a7e8f4735e227d9245e1457a2623bcb872858ea688a89a2e1862d023bdb0f28062cf37ec64df34665001bdae8712e9667f2eba277b3a00c048e0bc1ee25bf1c652c95c65de1eb4954a7c04a23a92e56b5ce3a1693bf351321e08ddddd4ddad98ccee80241f5e0b85e263e4035012fc713ba2b6a21d56581ea3f679871a0e410c00ae0894b948b7e5bfde847f7250cb9bba6d5974be08cd12414edb33210a046f118a80a5cef1c49705de438d12327a469438f362aac1e4ed82e7b81a7406f44362228f566930f3dcad562c33eb62e48ad8db8aced052cda4b6d15110841d265e8d2aa8afdcf7806891665d219e02099c3eeecc8a80ac30a4816494c3050802acf6d120f8f8b3743711bfb2eee1b7b3fee27c7da12337adf99541c4ec71553e6d50188704232b3a43aa5bc77cfe2d1c4dcd85f68e4a5d15c097371ad36f4e9eb9ae55c7d7ece4605c9805044afd1f31713869aa8fed257cdc9d8a07f0c9d450a64667324290c992395a6248dd99b815d5aec421dae310da0c0fb99b6b12f134e440d62552358a7b976a006f32489eddb59512c6197451156b9f086e37dbfab06627cb02959f4a64534d6a027820226006142e361b072b29263969296a7318a32ff28633d39f59a8dfe1f1123622181f42be997ce3eb9df05a5ac235ac859ca88daab58f473a70f0e702eb44a347463a2c9b2c244ca2f3b4a9f96b6f8d512f6c9a69352c71d32fe677ab904d2ddf42990f80ca37907064c4af263f75651a4ebee225317be4229c0edaaab16e5de0ca696db6a25f59df0c0f6256a8029cb0b44dcb0ddfc31b579ea9c4db774743116e750f55a1a5f87d873037c0176a44f1e186b01ffcd5425df307e62f8e02f1c42b2c8c474127f9c4d7b37459ca476c05a1da19ea31ef9fd2c0fb069bf1cb95fee82f06d0dec2d5c402ea42002471bea2f2b26d4cb923e14355e900052bc753e1d425ebe4a587496feb58c5809822258cc1e5f755cf4dc42b3e47d3e5c1f875c23913cbab40d023892a3a03e52c72b7f2272e4d570a737616fe2837cd98d83194c8cd31e5afea9c38cf7068834ca031a6ab2127f5275a3a17356e7e583f7713380129eccaf97002b113894dcb8ab73fd66f17ab062beaca604fcc4458acb38440121131af7190a186f41b4bca23c649deac5d28140103a517d99c4a4a8dd1f9acf8f1f63d937376a226950f6939ee6721d158c8782b1cc63289146fa1bc645cdf1272d8ba2f73f3bbf11837dd021be34036d404bd6eca5624ff54fd7efae4499b6b3245aac642b9d1dd0c642fd25d384e962a0f59f2ffcf4921212449b786beacab2c27fdd2b4ddbb764ac474fd99a4d075e13d1cd2aca0b0cb00fc4baff80808fca4023d3b7dca8f268b9496e5c1a21f7a62c453ac1bc2a5b068a37397d667b82038d1524c9c6fc7e1146b26b27c11a34f8acea9822dfcc60266ea565da188fe0e5cf755025164ec71a86ceef70da31c77a76b4d3114be8204142d1ab37b8b4b54dedea22d8d79efb3d40309689bb0584bfa38c0d37d9b9149328a0ea98e68e022c847e796c6e7911b4c4f8e113aa0328a3ad4ba53407910e09e63d79a7eb8ba1de4d0216f1d97e3fa7d687ab482dcb580adffde714e456ab0866e44990a6753e704890ee8442624333fb637bc8124e702506506cc8b1ababdfdb4d2b0b246609bbb21d79287ca5f63cbb970e35fae2ad6354621808a38f155dc30657501054d48c29a86c66c498123025c0be56362d3abf69fa79d1db6bfe8e5005369083554dc5961d9ae4d53b2f745cfc18cc7f63203f5baa6208dfbd9c676993a560aa7f582322a4e9321fc6157ca9cec61ff7e4f7212d1b2ec04cccc9dd9b0f6cfaace813a5bac7384687153a833f69c67cf854b02c8235494cf8a335c007ec5b7747faf420918798c6d5c38d9d57d8ac9034bc7733c24b6aedd7181c85b926280199d4ff3ad730eff9a63ebbdcda8d1f6de54b914ed4aa7bc9e7b4c06e04fc2f27e2a6a73f859da859f48cdfe02fdec297ba7f585bfdae241211a704f29e60a410fff9e6afe0320d8a03f75070de7ba1f6b930431e827fc42338f4cec5bd32ba157f2820b97057ab022f3c21f68abe19a8bf6114e938de964ccb2f0d15922dc0e4abd002cec746ff3067e36ef916282a869ba91b920d965c2d6084c79da0cc57d3245f94a4a0d991cf581e98f759191f77aeefd8552e46220819de24417850e3ee28878c0dd79e12f8d136b7fb936cf3dba3fae21a9064a951d5c3f636ad6374e11de631c488d911fb89ff3217e480f39b8ef675c9e580446e1713a00d1778309c92f85b49033bd8881513d6417b435c96ca0a3db03df65a39a51d078c9aad0186b4f4dac4051dc32a42bfa7942788822b732e054f268631eb321ea3102272cb74da7c783bb634bac6921e0bb41246b97a9c77bacdf4f999f93d754ea4873b9185295080b1b1bbfd9fe1297e095f471f0209a857cc0d37b6b6cbc4060c516055a8c33950cbb29da4aeb466c28cb421115176316152bc6db012c0c28feb1792e86a83dd4b3bec262c9af25e282cb5a35fd27ef3e3a8deff263a4f65c883373a7bb2711a9cbfae9e56bdf328bb8412fa6f60d6bef74436513def10561fc3962be06d5e587d48063a5ca56f16d9ca4dee40b0834669f1797bcdd5407c50dfd919a984d435d1e07a7126e00ec21278507ef7824166cded88a1876ca624629805b55defae550df49cf36a0cc0592f14cb3e5df574e5332b13811dfc7c685e7ef8f360131474e67b9cbb1d17bf02db44a082d541535c4721b1065a56019a6c9ea6e7201296eccd8bf85d70ddcf818e0079971e209e34ba1027284f90f5e7ec6507c4536530e67077478675015f17a83d187a53af7349f6bd166477f1b087802b3607e8f60b56a35e0a32908983521d7ba217fc62a5fa5a9aa1d17e075b2a67b806e9995dd6fc28b3e6e3426d27b0d4c4fad058f379ff82dad8994bba04eb9c7603d0f8e418c467ccc649e52812892a1aacb6031ff55bab60f8eab998a6358ef46c2e048da2ad4d8365dda9ecbecf959a33262e0e7609f83abaaeb299cb7eff470b786c75030771f1481741729facad0674898efa1a00a320592efb8e0776321cafcaa7ee1218f3ef4326dcedae1b17c94b051d2a2f4bde3129e9ec30de2b3f7be29fe86d001c9337e2adfc59ba0aa323654458e8eef4f26db0a1f285ccafe9374775dbd22f735cb6243f1c8f8a7dfad7b8554f5a233a0306693f76314ba6edc1820dde3d0ad11cb43965bf1ed05f13667d6c664761517d1024803edafe21e41c87d5fbe23e18d793e5be37b3da9af36fa867c2e6072954999d39f7d594007cb59f9d4600d793f69b014b38e4c6f1227db4028a0d381a8957798f9976c251015183d77b4e94971b0310a1b3d2ea18aa4f50a64de921206d777ed997df0cc28e16f16dc2fd0fa62654a1e2fbbe7e00f2459670d31ec15671b221b9b5c47060452c265c9ac8f6a1a665e5154817cc8cd22591a992cd1e251d87edc45f9f87937877f1575a13a7b5823a1033847cf7c6b437f89f2420905e379bfb5272d0d80b5a8456ece5f12dc3cf1e4f6bbb01387695437969c4e557a784365056fed9b19536bf23aa8c46b197721a364a2cfde4aad05aeb84b53e90a5d0fd6633fcf1af87fdc2af183830c40ab8f64e05539145f71aa2b358062d3ff37abb7af26961ad865358486b0acf9d918db420bf3b1b62e530a74b6ff768a01de0675fc01307ac9e4221af9711eb420de4712a69b54cd751a6650b1f17de509a9798a1e2286a53ab1e67da1deae20143bc32af98198ead4173d529c9e1f3b7d041533f6fec0d6ead4d3155ac2ca0708cf47875f39332bda724dd5f347455da72b1484e28ccafd0859d9f37e7377ec5bb3b8a215b73cc580e0228b68538d3e81a3842d24b5a7aea7edb0ec2469bc75039757d088c653d03a352da0246c501bbf17aab521a4e33287c7278938bca94aec855e28c8da65bfc7e0735771f386f60f94f10c44442ced0d025ff3444ce9747548f6255a9cbf41897423bf53677dd0535b39a439c795bf983d261897c99984bbd13baa359b1c","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"66a718b0758169003b5ebba199804efc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
