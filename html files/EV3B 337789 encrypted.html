<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ES216BB EV3B</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ES216BB EV3B</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="SUBMIT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f921daa96e39e4c7011dd8c536d1dd797bdaab54fc91bf6a80c829914eebd7b93364a2fdc4e782ff5e6cbb04725a8b6b96fb8c84b210400115f98c1bd8e35498161a77575e47b8ff80f6583df82bffbcd4f2448614b1a7dcfb621d51399a56809219a234416d4582b422f1a0be0ea5dedd32d32b3fd89fd4901e0a0c82411f500b8d9a4b5a1cde9b1ec89389b59f10da284f89aea01a37e2704aa511a1c2000027e16c833d7834fd7cfd98890af8cc39d495bd2d71f4f1f4e5932082e0bb9b38071f38b68719ab8fb3799b15e6aaad10ac1cf6d3bad51ffbbf263d85f4a2f63bc33c11a63e819059a5995c668bcf9f26d0079048dd1fc5ae56d07ebfb85c1946d5c8abeed205cdc36a7e162054704c38cd0e5c7cb50c0d341a8826c62f3b7bd4baec276225c70ba95f33c9449500d5757e691c813184322a651139ae063f43a02d0d86a654245312f9738efda6b4e01183cfb1412af9baee13b4222641cbe927d038c0279648fe418dc0a13f3393854535b1dc64c0bad25fa09298352646c76ab735e9469841f82bd028b6123cd9e85d3f8bb35dd9668af20a7208bfd5fd66259661aaa268b330b0e691785e07f20ff859a1e7e1ce8021d18b9edfff90cbc86e1242ddbeca989105a68534a5314c2e1c3c3d36f5e8a5ac7e0255e947b3c40a34f8f76ba95f2c5f2e04a396e82abb1f7e6498326019acc15d1fffdb085bd53686c003d687a6066eea065de28e643f806cb600a5fd1bac057e8a5907f085ad5130fef7babae741bb9041e19ccd663c8ab115c197a2d6ed226594e02fed114857880b89bd8ce107f882efc2d6b9fcabc035548b0c37ff407f5c590288ed8033a9b2ed46c4527f0414763f92c80b4d0b52ba6e06eee434e1798166dedff45183cc9c93e78e55fd8f59e2adc87d2d6b34c0069addee55e776814d9f1ef30876fdb3171ec9b1754cd53b8a7da9285e9bd66dd2233875426a0707db13163527046df34cd3ea83a0e1c27cd8f55210e80149ea641cd2337cef7bc90dd4ffbcd7045fbafc1c81d9446d3f40cedcb4ff8d4ca9546a10102462f7af2164b8ca6e0faae51b993dba71b20af492a50b4eb7d3bffb67910c5cd921e8f7088e035f75867aad0cbbbd5c438e00b1339e5bc56b32d184c190bffba5993ff5e2a9d7abdfc84c18edbca687ccc2a2aebffc869f690360c071c8aad3f26166f499a6fcefe89bf762b25cd18752b571b81dc507c580820933560860ef061a576cd7fd977a68eb7382edffad59ea22205587980681b6675b39bc1608ef80de10774b55ecb0f735d60327ae30936176dcdf072853ce005b2de711bff1b29bb9651855d9cb3a42e235a3abe49ba4717d2f4d974c48aab05c6820af1697c8971b310e63fbbd382bd96d5a7946c2f1a87147a7a309d204f7b207b5ad6df89aa213bf1f9b3fdadc2b6c3869e2e465848afb41222c35c1ca2df2877b443bff88a77f495445d7cfd87026b2cece6b891c13068e3837b0fb3075100f8476239323e09a08b253e04d286afd16a3801698e6505befd3b4e94a1a3580672bf4bbd57d664410bec61cacd7d4f5909964d8884f5c6cb5c47f41a74a257c46ff3c7b4bd766a89c3f69eee853226ade84fb52a4c365c796d14bb3d21fc2dd9c798216809e803ea213a8290647f00242dce06d1164da858fa3bad5ff61a2e6cae478ca299313175e7b0002b239ef148e34ed956636975308e0c4727cdc8d8b27083dd30117991d97d256d03178af8ddd56cf3c7330ec209728ab96a7bf14280f9ed9734b95a048cc887f3a0693975eb6e7ba1f0de2ad546e62b6f15aa19437b689258e45eeb6987888dbfb457ad7ae45f44568c92444c6587d5fb16eb9e54ca7bd9fda119b0d3285987079ecb935d752b892e55e1c7022044e44666640c3361b441fd618aa9d7f734647f4f33d10e1c79111cfe72ea52b1a1e314af8f9e87ddb0dc4b41cd6dd85f9226b5ca2503614e54af0083a42062174e6bf4457f3fcb77d70e763cd3ecc1ee5faca6f7ee109edd23c8a8a70dc8e0e0307792cafbdffd0a5c9a66e6a1838607bbce35e89b82f8ec2b8e2066eaf47552a058af1410c7d00f5f37c97df20bca6be2061075e36fd86fa1e7c322c6b687715e10279e1443a7ab79923c9d1ba19c5cdd15e697c7c1b71cb99e7c3c7f88de3b7f80f67f22c67d6fac07896a8c5ecb910902e80a8a237fd0088363357ac5d416f522afcf8962385bdadc3ca1765a30eae2acb42fa04c74b9b7f46aab87cc384e14057c5dd33819b8c5be7a84dfd9f6dcd05bfd61fc8e4ac1eb09b81a03afc9bcaf15f66faaed465500a63fde955f2469ded5afc0ccf87f15f896d4b0a70d4910d2ec0788496074d5c8b46bfe77347916f40d640fdfaccbf6d59025807a3ad24f06885d532d1831475baf7519a91ce85e8807cc8bd401b433d90626088c13dfd73909444f7291c4c8974c53e0805dfb42b48ee21f1decc71ed6bf083623af7af2695f629321a6fd989ed8bb05ae2362a1b5eb720313b8de4c607656c4da270fe96a790de5a1b9684c9728726b8f794689fd1fd854ab29f86da549c8eba4ec85caee01b7c7637d9becb8c9a71497819e543cc48e8f7d3f26cecb6fb83c76b1b0bb1eab29816cb0035eaffc305085c2af707194809fb9ca8de43e3fc33805868c5382fd67d9401ddd85d971d46a0d4e27f9aaf52329b53c6d0e39ad9492f6d6565b2093e81b0bdfbfe636f686185b194f7fdd578fd70f263bb9dd74d871637a21282e746fcaa13458a8d5db458690871afc7c0265bcabcdee60114b5681a37080ea436c9007717746b0793d066c81eaaec07c2dd056c51fb325cab937257d960df36560ac19813ddf2513fb8728b847f62ecd19f58b4bdaab6b0649b1cff2fc7384c415a62da366827b7c2211ea0f7c57d1d204f7ed3475c925062e7c20168a8630a524432283eba24e99bb9cd5c77579bd6f58e273af063318b40d1f4698a5dcf0bcecf50257bab61b357954b8edb670e8a471d3e62647ee18e801bd180b364bd341a7b2df933817366f1635dbcbc573533eb6112ba60d7d370f846c07d997b1d326e1d24b403f35ef390e82e0e760acf381512f8404046eb76359811326fdd1017e353d8c1f23108a323ca295ce38f589143f2b4f404187f220e735ec4ebfbc904e5fa7ba0a5ecb13ab93a8449021683b918422f0494b1f5dd5427f3d58b334def45379d43e1ef84aeb9e192f871e0250596ce58525345e0b180140c87ef17daa174c8252cc26bde752d613935efeb60d4ba32d8df57c2862350188fb20284c5bb37171507f41f8673a82aea186d916951bbe5bfc9ec2f19fc663be06239fbf0155471b7a6cf0255d9b8696d2ebc30b6ccab69ac1a57445167896e0befce5a06f7731c250ebf05beeea4800c81136db74d0dbabc3608b465e1fa3b26d862217491f2d04abc75d00e4d9a122f89a17232bf46be1a3fc483bba458d9af2b0df80b9e60ab1e078f07e97c25af0f71ce4312a7eda92c70b555ee3596162d27bbd91b508585185e36e3ce8551d95be7194abee36688d2d37e0ab85e6eee02aec783f010aae83bde4c4a31dc5db7b2754477565ed5fc46fedaae05b3b4ea00cfb3486758d5d2076adb3981c4ac40000e4ddc11e90e49dc26478bc0f4c580c49725b330ca5e1990eeb38dbd97d3c974b81a1600f75714020518c98ef9efbfdf1410deb9ec048774c8d34922e533722f3f4775e39fb443957a8670797bbae630065614b3d7b5975f2775c319e4e592b0c4984fadf5a96e4bd1f669a486fb8ae67c348fe1842b2cb11b367c51956e926ea64dcce452e5210520e52178238e149424fa229fe3eedc74bc7149451dc76b068d7315162297cccdf88e6422fdd0eedfb982f63c3d78e6003ff482ea1805b9b7dd6a48572d283ad7fc6a3365ffaf9b99804178e24a2fd3bfe73a27a42fc1b6a46f61ebc4a50723af83f3af1f1ddaa87ddeb3459693606f1a2711889f890e132e8891a960c41738efa5e9ffe8969e47129ee71a3af32d4693dea1d5c1a6602846d3dffd8b9a447b69847363a8941d401f22259d90f7d4d079e5123f123cc62733e3111c54c6f8d52013bc2034976f5b31c31b2fd9c3142fd54729b57b8d0c61f4c181cb850e04b87df9d502b42f99327ca74bc57215591db61a84df1cc6c3aee8c4720c90b6f3c1d61b1cef24af00fe0779e9265025d2dd1650d89e9931b717ad9e153b22644ad398ab58cd4860030fb87cc3cfe754d33e5e81e4c171ee8ffc15b72a6e9857c137ff693e2e3fe21beeb554a2c1ed348f88498fdd54b1d3692680f2b764ea9ac9269ac5d78781dc5b118aeb58e5e1fd0313ca8d80a9e1eb45136a54fe8923673f3234736f3e41c341957652bb0bc431bda68760ca4eab598de733018eb46ebc1dff982f99728b49c3f2e11b6c8c7ff5847dc3e8b875cf65dd9d0063ec9586f574e2b2b7e09976a08129a30ab5418f4c63ecce181338896c909c8d157c079b0b54036a1117edcab49f325d184a415ba2dda74a4f38eb5a6361b2c0b70ca32db70deaaab89353f92f8fa9ec5fdd1330dfd01b7f39cf78ed4048415d9eb064188c50f0bb39457461fe0dcb3ceb64c1c4e6f6ee7803318895907795f71d1a959f657ef01635c0bf6713237f46b7af7be4a7549b19f6b1c3db5f7b62bf3d501270793c09ecd5992e0137887fcbf1410a90a8f7067ca88db0a3e2ddf54949a1c701f845551265c538977bf42f0b6dec81e2a3aaabb8a20e9eeebc57c15a780d7228ceee02429c08af86df03f2622a7079f4d1d83b885671cef274cfcfdc08cea887cdb78e98eea5d93478d394f8792c422a867eaf595e3cdddf88324ed0ff6025f875d2d53502d6e1d9b2733e12aeaa28b5d1cd0892894bd182b9717e869e4c273673afd144ce756b289bff833b2e498b7787f4873d7b670c6cf351eea177958e99fede89c514c409340fdc025c88b97e02e5333b2e5d9bca2cc3b6572050c3f875d180509fc88fb284f50e7268f021eeeda01b0a502682c1dece56c8fccfdc37f95033e2efbaf5779988c36b5f554abd3f8830ae65b308b94e2f9a15792c2c18073d485c7cb226844543d0b06cbafe6d1fa2945a22c2a1202fbf0a44a3f45e4e0688cedbe8480ecf32c83e7656806b4bf3fc6d497561af171f7dff35086f824615b911fb2fc041163bf62c47779b648ad6734e2e5e85c557ed018f584e3e7527d6fb78bc1f1bea4b570a38298ce943adae31231c2ab511b28dcffbf3ca4dfbb6195eac52ce283eedc76bf158b88d6a5887259eb4e00084e5032e5ec4f243d299adc8f8fdd8152cf72707001928ed9b8d4ec925998ef9713bee8f48016cd8ddfbdd5be9d370bf0faec9631d19344d31cabca93d43c098327dc748f4773f6eaf4f537f356aaef54656ba6c89b394874abe631b5a169a1d4da07798266ecc7db932ec50984908b9e3039b602901b180be755876e0e3d456b480b98aa0f71d5518b5f1f1fbe611284318f11a779d5fe6bd7907303d61d18cbae82b8e239a15bfe8d0064a886df687612dfa0407e304da90f80427e535b70fac5534a3329c3f10e7fa758e9f6834498a0d71e5638e46454ad0e6a168b4858400771aefc18cf72dbb4284453d2981bea5d301ad499c60dbc38ace86a3e69eaa05675337212f47e25ed923b719bc2708d87a402ef3366755408b4dbaacdd8c6ede066ffe2ca39f88465c959cf1f4f5677ef6447cf7921388ee0f1ba8be2990cf367d0889cf8bd11a4476124f6149271730f916c4d566c867c572ed21d66876cf715bdefd0d5bc86cfcd95135c6fadf17b48b780685e2e7f9c0b0b7c4dea2795adac901a1bdfea433b0f2586e50ffd1594d926cb1c1190553e699840fe7014e7109175dfba32ceb2b02ee24c716a3e9f573cfa0e295ec100cb94967570581ffa3c79a2af8318e9103fcd219d7a6f5523458bd39b369c6d785b394cb10d5374c2b623f21dbc0470e53c7d30020193c1d6c3f4f2042c84093eb0da389ab1a3a3b6c75fa8a6742b5575afb39b4f5a3062975c2abd4a1557de0219f34603cf933a95e4866e91c5a0a0f780b647a61fc4316583b729a6ccf30bd5341e7de72f424a7662dc8fde60e42a60f1148173001c11f5e229fe9ecee433fc64b22935bd84672f43462e01cb242f37633097c32eddcf5a0f665e73f965e117ac8d388c9297b05f2c780ff0e4860e4b67d1ba6f0ff78c08cf612af8fa49cf41bd2926834a0c7032aa8e6f55470771c6399e69c443b50ae71c72bdb7320673389394c33d4a64c79f720d6867c69ba00c606cdb5b379c2d8d337626ebb2c9fceb6655d2788f932e2c4cb57fec8baa6a99646c4f552ad9e3f2ec70549ff49f4f23e9b79d788c442dfe6d57db04cb44925f34bd71d85d97b48f3e2fbbedfaa25f23647f0d7f7b511f7c7672e79b67f2c8026284127b6f187fe710d7638d67c7770ca1563940cc9cec162322db39f9a7a62deef8f2847c3bb348ad238859d73246e2c3ac4219b95fbf499b9e8cfc05e49562f3a224b426be8457e6500e28a37fbc8fb6c04a11370d28527dcadc29ab49ce96124f68eb6bed08c6422592c2a02246accc65ff162f83051771267320a02e3dc0c33094c0c0f0480c29063513a122b2bcdf32bd5a3c3cc8d4ed3bf3c1c477b81dd14335d09351d0e07de68e8716296f71247709db89a291345c1445fd6ec0702d855da46d921ba6444b440300d9fb93af143521dd3d8f9c72e4d0e9b7c1f83883f1a199087e68c28fe2c5aa1d99df4a90c2ebf1ae7ff16ddb96f4523df7713c5216ce63cf10831a1d2788dea97a3167c7fa342013d6abbeb74fc727cd334a3d357f612b134e1698bca58eaff69657adf03d01f31056eaed67a2c6691571545223e0323e18e9dd978f05eb8619ee1ce9e0ec61a5426150502ec0e692524ba7822ebc87ec21fee0146d09aea6431b62e42f39aea8e3032f56ad2202254017b6860abea422517dd977105f15e70ae8f76335061e854699dd0ad93b52815c2f39b90cf63a98e8076309979cf8370b955a281e75333e7c209791ff15f636eb115de2942f24e22b9dc9d85d05ee4f53c38597e28927e2e08e77f15550581c0a59dceba8c558dd0cfdd6c27f2c069f20d690c17e4f9788c50c32d4e0701a3c48bbdb864dfb0e7182f384b1a8a2e7a8899d0520fb94d2da5caefa78d95fd1874f1142b6b97097baabbc13bfb3b08baae6396b6f5fa1f959619597419a6fc2a9bd65040d871a9b641ee4ea43e31996be667dee092b110424c61139c0c0a7df01173ba8a197c565937f2cec78d5a9c3ecac01366e90b228336ecdc37874123d81f08bc62153dadddf1690056375dfb7b2e3a7aa8728f97ed349289b6f0cd76e732bdd3ad4fab21b7d6a93eeb5099ffa94325358d345e1fcf76d7ec019711e2952bd1fcce77b4b0060e569d6c13a7b1b452451edf2b2b3101dcb820df96aafb9a3e5297f0a66cd5c770c496f8df05653b6872ab8ea12e9ec082f182c64a19a6f6fdfc617cf577aba81372e87b9e8e2d4d8e913255f84b351af51a241264581a77384fb3a0b58cd6319d31ce4faba1e64059a820ac276293f353bb947fc2279710c69950a6495e889b7251e8995681448da19724364cd7215a69df86f4205414cda4e5a386b69fd349a3d064dffa81368c805126195b6db61d60a24e9361b868b40d4e85b078cd5cac911514af51626ba5c3f8aa98034dbcfd07dc821d09a7e93c75a64fcbe086b5ae5eff0f2d98b67071211cad918b5ce251fac44fa068af043f233d008658028acf964ebd97565a34018370b790cd131f90c4b63b18aa16c27880f7cbc357ddfe887ea4f867b3993280ad5ac066f4a1de8c6dd76d584a9e479393646078cb0d922059d62504d91ef3d0d81856f05eb910d578485c93b1a57cc34e92e47e74e8f0c2f74119e289df81ccefd77fa4086d3e7258d6fd3ea761fb0a73f63cf6bc33db1b2648a90e23ae98143bd753b4f4ff04fb425185fa172b26a957ab1c01b0bef9422c5a595efabb7b462c9a0fd0759163ed2e50082aa6eee4de9e33190bfd80fc7fa4ecfbb8f3669a06e13689814d6e42ecbbdff63f269edd8b70c4dd7c6b2246188f29d58989c9c0482ed744d4c72415cd078e02a5b1101816efae63c1570c031c2524948ef32f019e28fe8b0bfbcb8b96e184c16599049a761433dfa33acf6cacd191a29b236d7dd5c47295df7a8e32649d4686ddf73b5ab4569b013484a1bbdd17f4d9a77244a23428c19960c1a0878696865c604aa87f885cfdd396f716b6559754bc226aa04e8cbd7b17bd10f2b553c860dac101484daa3c36b67095df8b20ea36b09df564cbcf9c3379a99ce9e8e32cb2161bb0f5980a441fffc3a67044175f9c9c74bb4d69957b740da58624e28b63db8068028a99b823e047aad591708f01511d65e22a88d0465f20edffa61fa785db14a4e3b6622dc08aeda1df6716223e92df80ff54fbf081b33de1f68d506709d49ddb02c98500cc3b2fbe6443c4d7861577481b6327177d477976888d2d83e0a3eb6df7d3d160ddaae8941a6686c42bec293d796bd11b5ca1c350790e96123ce0181e066eb481ccb1ba1c7f88136e239f4ee91faac65175932f0e4fcc3ec9be8d1b6411b67b59176f3e73a40d7fb74d67f6ab77375b61cf60be2a21fe2d26b9dba540d2d26c9a03a929895df25388a1d3e2df7d3a53c44f2aba1ef2f6592973b39cbcb9cf99c96cfad4418a11ae832f99d2f15298668239afd1f366883dad1f077758ac928cb7cbb432a37a5fe7e64934425bd6b838de1f4efad3f4d3a2d5a047fece8afd3d28010612a3705da09cc36bb5bbeb48c0bf1119b1c17f6001503a73e3093fdbd1d1e9543d1278b80ac08beb9417715f8a1bc4c6f9201ff19c91ad91e986683134c9b4c4e58d9b4d51ed8e0aa3c901f36fa64f4f80e2433df9aac880c534e049d06ed55a80359e350478a1a6c09e0c9a40134e5ec9a5b48ca031b8a771f536a58d28331374ecdcab3303882127dcc163fbb1d6cfe8b6547c1be5a16792865795c6ccec6c320e2f2d53d817c95e0c1a398910c401411d7c018e4b6bcebd80cf8e7c3464f8a1f7019728e9b2b2d6e84fcaa61ea11dbb871cbdbe3023e088be32b2296c0a27691b8e3e0e4a1e8a75792e36f7e75ce3052894694b5e902fb301b452ddcdecda162c52d65167de02c09064e49fea52e9ed2dc2baa5b46f488c0ba9b758e8e5737b85c668e1dce438850f5a3ae83c3ed8ac6b0e506b6509fc16ed9c8e5abc98d0912d593ae4ee17ca82e1c0b69e915f925924b9bf782e072a436a75816ca017731dbf5a4add0ba62a79656f83cbfeb81d11d4ae9064d759f2621e867c05731b53a01c1b28f17266ccfaeeb1c935f22f07a753f1a09543b85df387d68c51668e20a312e7ea4d4273c11ce8d0e64a3ca43d05205d2b483b5a3351b8d30a352f8edcd8e61f37333b4db92905466bb04cf1d4583e6581560423b576026117fdfdb3ab6a5c9ac9749b8f7003a96e4c6a7c88a770ae01ee5bc155ec0ee1088a7437e7ee60239d8c2d9e27f8b65a7405a342e894e7a315c82a665c960abd70d72adb93d5b77e4b81b002ab08887ac8f008ab51180d2af534e0ae6767ef8efe7800c57c10afff1060abb475b85faafd3a201f8b4143eec90999c6ec32b2bc0cc6b3d2a6b2227f1cf4c9404dd68cf5ddd7de28141d6679491dd399dcb6f8786cba6fdb7bb5c3f86fd1e43f12cacdf1d63b3c8b8137fa5cc0c9f4fcf3f17690fa90a77a33486ddd1d00dc38e9c9a989647840cc9f495da2b5b943e814f396d2767d87acd6d75f4d643872bc009dc0a740c34ea217667ea88561af85a3e86d5ede67743082f70e2ebe4b8788c5c60a32845b8b68b2384c29789f89a4879aa33e65a1f078875f5b56bdbda9ebdd199dc0bcdefbefd352b624525d0d1cc59414f813f16995ada353b8273074417689299b1f6efca7fae18be7d6ea75a4b736f70764fc9c3f1f926f7d03d82c99b5f1ddd505c03c5d4fd6b102a884d100a47c3b69ea6c38db6c75afa7262533fa47183d9f6c578efb61ff0441560a081816b43e9cf21983af9a2eb24b27e61c128c292a745a0f11b5a912e7043deffcd174282b229869df642ba8f610751f907cbac86fc02d7c0bd7298c687fea82f6ce6d16638acc9103706afd4f4140ad2a1b0b245d92d0b7110844621816c964c15c3a5f2aafaafd0bf4c0d5204d92538d9b4005a1d1fb2e728323955db646054d2da27f97857b6e0c9640d9a40bf581ab02cb33ec3b695938e85ff8517e98423aeb7c2367bc3483f4874ded45a8ff0183c045dc3ff528043852b2d008427d5718f2bb7b979dab9de3c4d91e0d52308c252c72cbd8c8cee447d2856c945351855827cfe4a21dea467c1a1d5131b14a75621e70574be8169ee78d2880aec03f7b0bb5add8805429e8daa934a0e25097a6869ce39ed7609a302567fbfd66bb9784afd7bf3ecd83bef86fc9c5ee0bedbaebd57a8f293f363b99e45ad3d0ccb0c6539b0598b5d83b649336a61a37d34729023de56012e8ffeec9014dca657db23a7adb22b82edbf4a125f7ee1cc5393a29d4cc16845d6505bfbdca80a173398e351bcee7e1c2a90d6dbc53362fab3d2577912cf7dbf83db76be41892f17caf96b45f43399807d2614fa9802538e397d5967284641b69243d38e92c16cb6ba8df344568fdef7eabb39209d83fdc3e2caaddea29bbe4bfca28e6ce50513fc83726c593d7952fa31757c4cdfe8ae0c4b657c592ebd78c6687bd2978195aae72d3db63a998f85bd2ffccc686d3403a7f7c70e6a5d62b458e28ed205ae26f4d5a8a4cf4c9153651f8a6d011c082defb48426c9223cfe478f979e30a97952ab7d9ab4359f620e696767e990153443ff2c87b465370c6d6b1f108538718614cbf8d983d3eff07e2e81964777cd759c29da034c89b95f0e7f70af0f94aa7434c89b89ffdf1e0d2ffb54ab8113c018147a52c252f8","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"627d75346f014575dc46ea48fe2075f1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
